<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Griffin.Core</name>
    </assembly>
    <members>
        <member name="T:Griffin.ApplicationServices.AppConfigServiceSettings">
            <summary>
                Uses <c>app.config</c> (eller <c>web.config)</c>) to identify services that should be started by Griffin Framework.
            </summary>
            <remarks>
                <para>
                    There must exist a key per service in <c><![CDATA[<appSettings>]]></c>. It defines wether a service should be
                    running or not. <see cref="T:Griffin.ApplicationServices.IApplicationService"/>. The name
                    should be "ClassName.Enabled". For instance if you have a class named "StatisticsGenerator" the key should be
                    named "StatisticsGenerator.Enabled":
                    <c><![CDATA[<add key="StatisticsGenerator.Enabled" value="true" />]]></c>
                </para>
                <para>
                    Services which keys are not found are interpreted as being disabled.
                </para>
            </remarks>
            <example>
                <para>Class</para>
                <code>
            public class StatisticsGenerator : IApplicationService
            {
                // [...]
            }
            </code>
                <para>
                    app.config setting:
                </para>
                <code>
            <![CDATA[
            <configuration>
             <appSettings>
               <add key="StatisticsGenerator.Enabled" value="true"/>
             <appSettings>
            </configuration>
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.ApplicationServices.ISettingsRepository">
            <summary>
                Settings used by <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/> and <see cref="T:Griffin.ApplicationServices.BackgroundJobManager"/>.
            </summary>
            <remarks>
            <para>This contract represents a configuration source. It might be your app/web.config or a database table.</para>
            </remarks>
            <seealso cref="T:Griffin.ApplicationServices.AppConfigServiceSettings"/>
        </member>
        <member name="M:Griffin.ApplicationServices.ISettingsRepository.IsEnabled(System.Type)">
            <summary>
                Check if a service/job should be running.
            </summary>
            <param name="type">
                A type that implements <see cref="T:Griffin.ApplicationServices.IApplicationService"/> or <see cref="T:Griffin.ApplicationServices.IBackgroundJob"/>.
            </param>
            <returns>
                <c>true</c> if the service/job should be running.;<c>false</c> if it should be shut down.
            </returns>
            <exception cref="T:System.ArgumentNullException">type</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppConfigServiceSettings.IsEnabled(System.Type)">
            <summary>
                Check if a service/job should be running.
            </summary>
            <param name="type">
                A type that implements <see cref="T:Griffin.ApplicationServices.IApplicationService"/> or <see cref="T:Griffin.ApplicationServices.IBackgroundJob"/>.
            </param>
            <returns>
                <c>true</c> if the service/job should be running.;<c>false</c> if it should be shut down.
            </returns>
            <exception cref="T:System.ArgumentNullException">type</exception>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings">
            <summary>
                Settings for the app domain host.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.Validate">
            <summary>
                Validate settings.
            </summary>
            <exception cref="T:System.InvalidOperationException">Failed to read/write same value from registry.</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.PickupPath">
            <summary>
                Folder where new releases are placed.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.AppDirectory">
            <summary>
                Base directory for new versions.
            </summary>
            <remarks>
                <para>
                    New versions are put in sub directories to this folder.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.ApplicationName">
            <summary>
                Name of the application
            </summary>
            <remarks>
                <para>Used to generate registry settings.</para>
            </remarks>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.CompanyName">
            <summary>
                Company/organization name
            </summary>
            <remarks>
                <para>Used to generate registry settings.</para>
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection">
            <summary>
                Represents a connection to a client in the named pipe server.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.#ctor(System.String,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection"/> class.
            </summary>
            <param name="pipeName">Name of the pipe.</param>
            <param name="instanceCount">The instance count.</param>
            <exception cref="T:System.ArgumentNullException">pipeName</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.Start">
            <summary>
                Start receiving information from the remote end point.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.BeginRead">
            <summary>
                Begin receiving information.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.Write(System.String,System.String[])">
            <summary>
                Write a command over the connection.
            </summary>
            <param name="command">Command name</param>
            <param name="argv">Argument list</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.Stop">
            <summary>
                Stop server.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.UserState">
            <summary>
                You can assign your own object here to identify the connection
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.Connected">
            <summary>
                Checks if we are connected. Not thread safe nor 100% reliable as all disconnects such as network failure are not
                automatically detected.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.ReceivedCommand">
            <summary>
                Received a command from the server.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.Disconnected">
            <summary>
                Detected a disconnect.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.UnhandledException">
            <summary>
                An unexpected exception.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs">
            <summary>
                Arguments for <see cref="E:Griffin.ApplicationServices.AppDomains.Controller.ClientConnection.ReceivedCommand"/>.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs.#ctor(System.String,System.String,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs"/> class.
            </summary>
            <param name="clientId">The client identifier.</param>
            <param name="command">The command.</param>
            <param name="argv">The argv.</param>
            <exception cref="T:System.ArgumentNullException">clientId</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs.ClientId">
            <summary>
            App domain identifier
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs.Command">
            <summary>
            Command being execited
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.ClientReceivedCommandEventArgs.Argv">
            <summary>
            Arguments for the command
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Controller.ReceivedCommandHandler">
            <summary>
            Delegate used to process incoming commands
            </summary>
            <param name="command">Name of the command to execute</param>
            <param name="argv">Arguments for the command</param>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Host.ReceivedCommandHandler">
            <summary>
            Delegate used when receiving commands
            </summary>
            <param name="command">Command name</param>
            <param name="argv">arguments</param>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.NamespaceDoc">
            <summary>
            Hosts your application in a separate AppDomain to be able to provide runtime upgrades.
            
            </summary>
            <remarks>
            <para>
            Not yet complete.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.UnhandledExceptionEventArgs">
            <summary>
                Detected an exception.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.UnhandledExceptionEventArgs.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.UnhandledExceptionEventArgs"/> class.
            </summary>
            <param name="exception">The exception.</param>
            <exception cref="T:System.ArgumentNullException">exception</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.UnhandledExceptionEventArgs.Exception">
            <summary>
            Exception that occurred.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector">
            <summary>
                The purpose is to monitor the pickup path for changes and then copy the new version to a new version folder.
            </summary>
            <remarks>
                <para>
                    The class waits 30 seconds from the last change before initiating a copy. The wait is done so that we are sure
                    that no new changes
                    have been added.
                </para>
                <para>
                    Version folders are just named as the DateTime (<c>date.ToString("yyyy-MM-dd_HHmmss")</c>) for the newest file
                    in the pickup directory.
                </para>
                <para>
                    You can specify your own directory security for the version folders by setting the <see cref="P:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.Security"/>
                    property.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector"/> class.
            </summary>
            <param name="pickupPath">Folder to monitor</param>
            <param name="appPath">Folder to create version folders under.</param>
            <exception cref="T:System.ArgumentNullException">
            pickupPath
            or
            appPath
            </exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.Start">
            <summary>
                Start monitoring for new releases in the <see cref="P:Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings.PickupPath"/>,
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.Stop">
            <summary>
                Stop monitoring for new releases.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.Security">
            <summary>
                Custom security settings for the new (application) folders.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Controller.NewVersionDetector.VersionFound">
            <summary>
                A new version was found.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Controller.VersionFoundEventArgs">
            <summary>
                Version that was found.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Controller.VersionFoundEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.Controller.VersionFoundEventArgs"/> class.
            </summary>
            <param name="versionPath">The version path.</param>
            <exception cref="T:System.ArgumentNullException">versionPath</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Controller.VersionFoundEventArgs.VersionPath">
            <summary>
                Full path to the version directory (that the <c>NewVersionDetector</c> created after discovering new binaries).
            </summary>
            <remarks>
                The specified path is the one that should be started within a new <c>AppDomain</c>.
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain">
            <summary>
                Represents a running appdomain instance.
            </summary>
            <remarks>
                <para>
                    this class is run in the main app domain and communicates with the application AppDomain using
                    <see cref="T:Griffin.ApplicationServices.AppDomains.Host.AppInitializeRunner"/>.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.#ctor(System.Type)">
            <summary>
            </summary>
            <param name="startType">
                Class which starts the application, can be compared with global.asax in ASP.NET or the service
                class for Windows services.
            </param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.Configure(System.String,System.String)">
            <summary>
            Configure this domain
            </summary>
            <param name="id">AppDomain identifier</param>
            <param name="appDirectory">Directory where new versions are stored (in sub folders)</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.Start">
            <summary>
                Launch app domain and start the services in it.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.ProcessRemoteCommand(System.String,System.String[])">
            <summary>
                A command received from the <see cref="T:Griffin.ApplicationServices.AppDomains.Host.AppInitializeRunner"/> through the named pipe.
            </summary>
            <param name="command">command to execute</param>
            <param name="argv">arguments for the command</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.Stop">
            <summary>
                Stop this app domain
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.RunningSince">
            <summary>
            When this domain was started (UTC)
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.Id">
            <summary>
                Generated id for this specific app domain
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.AppDomainException">
            <summary>
                An exception was caught in the hosted app domain
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain.PanicRequested">
            <summary>
                Failed to launch or run this version. Roll back to previous version.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.IUpdateInformation">
            <summary>
            Information about a detected application update.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.ApplicationManager`1">
            <summary>
                Takes care of all app domains that have been created due to new files.
            </summary>
            <remarks>
                <para>
                    Launches the application in a shadow coopeid
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.ApplicationManager`1.#ctor(Griffin.ApplicationServices.AppDomains.ApplicationManagerSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.ApplicationManager`1"/> class.
            </summary>
            <param name="settings">The settings.</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.ApplicationManager`1.Start">
            <summary>
                Start application manager.
            </summary>
            <remarks>
                <para>
                    Starts the current version of the application and also begins to monitor for new versions.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.ApplicationManager`1.Stop">
            <summary>
                Stop application manager
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.IApplicationInitialize">
            <summary>
                Implement this class to run one or more services inside an isolated AppDomain.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.Start(System.String[])">
            <summary>
                Start a service
            </summary>
            <param name="argv">Application arguments</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.Stop">
            <summary>
                Stop service
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.Pause">
            <summary>
                Pause service (continue to run, but do not process anything)
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.Resume">
            <summary>
                Resume after being paused.
            </summary>
            <exception cref="T:System.InvalidOperationException">Is not paused.</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.OnUpdateAvailable(Griffin.ApplicationServices.AppDomains.IUpdateInformation)">
            <summary>
                We've detected an update.
            </summary>
            <param name="information">Information about the update.</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.RequestRestartPermission">
            <summary>
                An updated have been detected and an restart is pending.
            </summary>
            <returns><c>true</c> if application can be restarted; otherwise <c>false</c>.</returns>
            <remarks>
            <para>
            You can deny a restart if your application is doing something that will fail during a restart. The framework will the try again later.
            If you return <c>true</c> the <c>Stop()</c> method will be called for this app domain and then <c>Start()</c> will be called in the new app domain.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.IApplicationInitialize.SupportsPause">
            <summary>
                Supports pausing (still running but not processing anything)
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.IConfigAdapter">
            <summary>
                A writable configuration source
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.IConfigAdapter.Item(System.String)">
            <summary>
                Access a config setting
            </summary>
            <param name="name">Name of the setting</param>
            <returns>value if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter">
            <summary>
            Used to keep configuration settings in the registry (in CURRENT_USER).
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter"/> class.
            </summary>
            <param name="companyName">Name of the company.</param>
            <param name="appName">Name of the application.</param>
            <exception cref="T:System.ArgumentNullException">
            companyName
            or
            appName
            </exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter.GetStringValue(System.String)">
            <summary>
            Get a value
            </summary>
            <param name="name">setting name</param>
            <returns>
            value if found; otherwise <c>null</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">name</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter.SetValue(System.String,System.Object)">
            <summary>
            Set a value
            </summary>
            <param name="name">Setting name</param>
            <param name="value"><c>null</c> to remove value</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter.OpenKey(System.Boolean,Microsoft.Win32.RegistryKey@,Microsoft.Win32.RegistryKey@)">
            <summary>
            Opens the key.
            </summary>
            <param name="writable">if set to <c>true</c>, the registry setting should be opened as writable.</param>
            <param name="companyKey">The company name.</param>
            <param name="appKey">The application name.</param>
            <exception cref="T:System.InvalidOperationException">Failed to create ' + _companyName + ' under CURRENT_USER.</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.RegistryConfigAdapter.Item(System.String)">
            <summary>
            Get a settings value
            </summary>
            <param name="name">Name of the setting.</param>
            <returns>value if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.RestartOrder">
            <summary>
                How to restart applications
            </summary>
        </member>
        <member name="F:Griffin.ApplicationServices.AppDomains.RestartOrder.StopOldFirst">
            <summary>
                Stop the old AppDomain before starting the new one.
            </summary>
            <remarks>
                <para>
                    The old one will be restarted if the new domain fails to start. This also means that no AppDomain will be
                    running for a short while.
                </para>
            </remarks>
        </member>
        <member name="F:Griffin.ApplicationServices.AppDomains.RestartOrder.StartNewFirst">
            <summary>
                Start the new AppDomain before shutting down the old one.
            </summary>
            <remarks>
                <para>
                    This means that there will always be an AppDomain running, but both AppDomains will be running side-by-side for
                    a short while. This means that
                    operations in your application might produce duplicate result depending on how you have designed your
                    application.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.UnhandledExceptionStringEventArgs">
            <summary>
                Detected an exception (in a app domain so we use <c>exception.ToString()</c> to make sure that we are not missing the assembly that the exception is defined in)
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.UnhandledExceptionStringEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.AppDomains.UnhandledExceptionStringEventArgs"/> class.
            </summary>
            <param name="exception">The exception.</param>
            <exception cref="T:System.ArgumentNullException">exception</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.AppDomains.UnhandledExceptionStringEventArgs.Exception">
            <summary>
            Exception that occurred.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs">
            <summary>
                Could not start (or restart) a service.
            </summary>
            <remarks>
                Assign <see cref="P:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs.CanContinue"/> to specify if we can continnue to check services.
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs.#ctor(Griffin.ApplicationServices.IApplicationService,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.BackgroundJobFailedEventArgs"/> class.
            </summary>
            <param name="applicationService">Tjänsten som inte gick att starta igen</param>
            <param name="exception">Undantaget som kastades.</param>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs.ApplicationService">
            <summary>
                Service that we could not start (or restart).
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs.Exception">
            <summary>
                Thrown exception
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceFailedEventArgs.CanContinue">
            <summary>
                Continue to check the rest of our services.
            </summary>
            <value>
                Default is <c>false</c>.
            </value>
        </member>
        <member name="T:Griffin.ApplicationServices.ApplicationServiceManager">
            <summary>
                Used to manage services that runs as long as the application (i.e. single instance classes)
            </summary>
            <remarks>
                <para>
                    Services that have been enabled/disabled during runtime will be started/stopped automatically by this library
                    if they
                    implement <see cref="T:Griffin.ApplicationServices.IGuardedService"/>. Same goes for services which have crashed.
                    Otherwise they will only be started/stopped when <c>Start()</c>/<c>Stop()</c> is invoked on this manager.
                </para>
                <para>
                    You can also start/stop services at runtime using your config file (app/web.config) if you use the
                    <see cref="T:Griffin.ApplicationServices.AppConfigServiceSettings"/> class as configuration source (or your own implementation).
                </para>
                <para>
                    If you are using a inversion of control container your classes should be registered as "Single Instance" in it
                    for this class to work properly.
                </para>
            <para>
            The following signals are implemented (see <see cref="N:Griffin.Signals"/>):
            </para>
            <list type="bullet">
            <item>
            <term>ApplicationServices[fullTypeNameForServiceClass].Disabled</term>
            <description>Application service have been disabled through configuration</description>
            </item>
            <item>
            <term>ApplicationServices[fullTypeNameForServiceClass].Running</term>
            <description>Application service is currently running</description>
            </item>
            <item>
            <term>ApplicationServices[fullTypeNameForServiceClass].Faulted</term>
            <description>Fails to start service successfully.</description>
            </item>
            </list>
            </remarks>
            <example>
                <para>Start by creating a class:</para>
                <code>
            public class MyQueueReader : IApplicationService
            {
                ServiceBusReader _reader;
            
                public MyQueueReader(/* can use dependency injection */)
                {
                    _reader = new ServiceBusReader(blabla);
                }
            
                public bool IsRunning  { get { return _reader.IsRunning; } }
            
                public void Start()
                {
                    _reader.Start();
                }
            
                public void Stop()
                {
                    _reader.Stop();
                }
            }
            </code>
                <para>To enable the service in your app.config:</para>
                <code>
            <![CDATA[
            <configuration>
             <appSettings>
               <add key="MyQueueReader.Enabled" value="true" />
             <appSettings>
            </configuration>
            ]]>
            </code>
                <para>
                    Finally you have to create the service manager:
                </para>
                <code>
            // Discover all classes that implement IApplicationservice
            var serviceLocator = new AssemblyScanner();
            serviceLocator.Scan(Assembly.GetExecutingAssembly());
            
            //run the services.
            _serviceManager = new ApplicationServiceManager(serviceLocator);
            _serviceManager.Start();
            
            // [...]
            
            // .. when the application is shut down..
            _serviceManager.Stop();
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.#ctor(Griffin.Container.IContainer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/> class.
            </summary>
            <param name="container">Inversion of control container (griffin adapter to support all containers).</param>
            <exception cref="T:System.ArgumentNullException">container</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.#ctor(Griffin.ApplicationServices.IAppServiceLocator)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/> class.
            </summary>
            <param name="serviceLocator">Implementation used to find all registered services.</param>
            <exception cref="T:System.ArgumentNullException">container</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Disable(System.String)">
            <summary>
                Disable service (so it will be shut down during the next service check).
            </summary>
            <param name="className">Name of class (with or without namespace)</param>
            <remarks>
                <para>
                    Requires that the service implements <see cref="T:Griffin.ApplicationServices.IGuardedService"/>.
                </para>
                <para>
                    This will override the setting in the configuration file.
                </para>
            </remarks>
            <example>
                <code>
            serviceManager.Settings.Disable("YourClassName");
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Disable(System.Type)">
            <summary>
                Disable service (so it will be shut down during the next service check)
            </summary>
            <param name="type">Type to disable</param>
            <remarks>
                <para>
                    Requires that the service implements <see cref="T:Griffin.ApplicationServices.IGuardedService"/>.
                </para>
                <para>
                    This will override the setting in the configuration file.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Enable(System.String)">
            <summary>
                Enable a service (so that it will be started during the next service check)
            </summary>
            <param name="className">Name of class (with or without namespace)</param>
            <remarks>
                <para>
                    Requires that the service implements <see cref="T:Griffin.ApplicationServices.IGuardedService"/>.
                </para>
                <para>
                    This will override the setting in the configuration file.
                </para>
            </remarks>
            <example>
                <code>
            serviceManager.Settings.Disable("YourClassName");
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Enable(System.Type)">
            <summary>
                Enable service (so it will be started during the next service check)
            </summary>
            <param name="type">Type to disable</param>
            <remarks>
                <para>
                    Requires that the service implements <see cref="T:Griffin.ApplicationServices.IGuardedService"/>.
                </para>
                <para>
                    This will override the setting in the configuration file.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Start">
            <summary>
                Start all services and start monitoring them.
            </summary>
            <exception cref="T:System.AggregateException">
                Contains one or more <see cref="T:Griffin.ApplicationServices.StartServiceException"/> with information about the services that could not be
                started.
            </exception>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.Stop">
            <summary>
                Will shut down all services and stop checking their health.
            </summary>
            <exception cref="T:System.AggregateException">Contains a list of errors for all services that could not be stopped.</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceManager.CheckServices">
            <summary>
                check services wether they should be started/stopped.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceManager.Settings">
            <summary>
                Used to be able to determine which services should be running
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceManager.CheckInterval">
            <summary>
                Hur ofta som vi ska kontrollera om tjänsterna är uppe och rullar
            </summary>
            <remarks>
            </remarks>
            <value>Default är var 30:e sekund.</value>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceManager.StartInterval">
            <summary>
                Amount of time before starting services for the first time.
            </summary>
            <value>
                Default is 5 seconds.
            </value>
        </member>
        <member name="E:Griffin.ApplicationServices.ApplicationServiceManager.ServiceStartFailed">
            <summary>
                Failed to start a service (no matter if it's for the first time or later on)
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.ApplicationServiceManager.ServiceFailed">
            <summary>
                Service failed to execute properly (an unhandled exception was caught).
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.ApplicationServiceThread">
            <summary>
                An application service which runs inside a thread.
            </summary>
            <remarks>
                <para>
                    Make sure that you wait on the wait handle to support graceful shutdowns.
                </para>
            </remarks>
            <example>
            <code>
            [ContainerService(Lifetime = Lifetime.SingleInstance)]
            public class TestAppService : ApplicationServiceThread
            {
            	public TestAppService()
            	{
            		
            	}
            
            	protected void Run(WaitHandle shutdownHandle)
            	 {
            		 while (true)
            		 {
            			 try
            			 {
            				 // pause 100ms between each loop iteration.
            				 // you can specify 0 too
            				 if (shutdownHandle.WaitOne(100))
            					 break;
            	 
            				 // do actual logic here.
            			 } 
            			 catch (Exception ex)
            			 {
            				 // shutdown thread if it's a DB exception
            				 // thread will be started again by the ApplicationServiceManager
            				 if (ex is DataException)
            					 throw;
            	 
            				 _log.Error("Opps", ex);
            			 }
            		 }
            	 }
            }
            </code>
            </example>
        </member>
        <member name="T:Griffin.ApplicationServices.IGuardedService">
            <summary>
            Guarded services can be stopped/started/restarted by this library during runtime.
            </summary>
            <remarks>
            <para>
            You can use app/web.config to disable/enable the service (even during runtime).
            </para>
            <code>
            <![CDATA[
            <configuration>
             <appSettings>
               <add key="YourClassName.Enabled" value="true"/>
             <appSettings>
            </configuration>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.IApplicationService">
            <summary>
                A service which are doing some kind of work during the entire application lifetime (i.e. sort of an instance service).
            </summary>
            <remarks>
            <para>
            This library can use your inversion of control container to find and execute all services registered in it. The librar will also catch any unhandled exception
            and restart services that fail. You can also use your configuration file to start/stop services during runtime.
            </para>
            </remarks>
            <example>
            <para>Let's say that you have a service which reads from a message queue:</para>
            <code>
             public class RequestQueueReader : IApplicationService
             {
                 private readonly ILog _logger = LogManager.GetLogger(typeof (RequestQueueReader));
                 private readonly IContainer _container;
                 private readonly QueueReader _reader;
                 private int _retryCounter;
            
                 public RequestQueueReader(IContainer container)
                 {
                     _container  container;
            
                     var queueName = ConfigurationManager.AppSettings["RequestQueue.Name"];
                     if (queueName == null)
                         throw new ConfigurationErrorsException(
                             "Did not find 'RequestQueue.Name' in appSettings. Configure it.");
            
                     _reader = new QueueReader(queueName, new XmlMessageSerializer(new[] {typeof (RequestMsg)}));
                     _reader.MessageReceived += OnMessageRead;
                     _reader.Faulted += OnFaulted;
                 }
            
            
                 public void Start()
                 {
                     _reader.Start();
                 }
            
                 public void Stop()
                 {
                     _reader.Stop();
                 }
            
                 private void OnMessageRead(object sender, MessageReceivedEventArgs e)
                 {
                     var message = (Anno) e.Message;
                     _annoMessageHandler.Handle(message);
                     _retryCounter = 0;
                 }
             }
            </code>
            </example>
            <seealso cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/>
        </member>
        <member name="M:Griffin.ApplicationServices.IApplicationService.Start">
            <summary>
                Starta vad det nu är som tjänsten hanterar.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.IApplicationService.Stop">
            <summary>
                Stäng ned det som tjänsten hanterar
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.IGuardedService.IsRunning">
            <summary>
            Returns if the service is currently running
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.IGuardedService.Failed">
            <summary>
            Service failed to execute.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceThread.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ApplicationServiceThread"/> class.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceThread.Start">
            <summary>
                Starta vad det nu är som tjänsten hanterar.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceThread.Stop">
            <summary>
                Stäng ned det som tjänsten hanterar
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceThread.Run(System.Threading.WaitHandle)">
            <summary>
                Run your logic.
            </summary>
            <param name="shutdownHandle">Being triggered when your method should stop running.</param>
            <example>
                <code>
            protected void Run(WaitHandle shutdownHandle)
            {
                while (true)
                {
                    try
                    {
                        // pause 100ms between each loop iteration.
                        // you can specify 0 too
                        if (shutdownHandle.WaitOne(100))
                            break;
            
                        // do actual logic here.
                    } 
                    catch (Exception ex)
                    {
                        // shutdown thread if it's a DB exception
                        // thread will be started again by the ApplicationServiceManager
                        if (ex is DataException)
                            throw;
            
                        _log.Error("Opps", ex);
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="E:Griffin.ApplicationServices.ApplicationServiceThread.Failed">
            <summary>
                Failed to execute service.
            </summary>
            <remarks>
            <para>The string is the log entry to write to the log.</para>
            </remarks>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceThread.StopWaitTime">
            <summary>
                How long to wait on the thread for completion before terminating it.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceThread.IsRunning">
            <summary>
                Returnerar <c>true</c> om tjänsten är uppe och snurrar.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.ApplicationServiceTimer">
            <summary>
                An application service which runs within a timer
            </summary>
            <remarks>
                <para>
                    Do note that this implementation do not wait on completion when being shut down using <c>Stop()</c>.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceTimer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ApplicationServiceTimer"/> class.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceTimer.Start">
            <summary>
                Starts the internal timer.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceTimer.Stop">
            <summary>
                Stop the internal timer.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ApplicationServiceTimer.Execute">
            <summary>
                Used to do work periodically.
            </summary>
            <remarks>
                Invoked every time the timer does an iteration. The interval is configured by <see cref="P:Griffin.ApplicationServices.ApplicationServiceTimer.FirstInterval"/> and
                <see cref="P:Griffin.ApplicationServices.ApplicationServiceTimer.Interval"/>. The intervals
                are paused during the execution of <c>Execute()</c> so that your method is not invoked twice if it doesn't complete
                within the specified interval.
            </remarks>
            <example>
                <code>
            protected override void Execute()
            {
               //Do some work.
            }
            </code>
            </example>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceTimer.FirstInterval">
            <summary>
                Interval before the first invocation
            </summary>
            <value>
                Default is 500ms.
            </value>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceTimer.Interval">
            <summary>
                Interval *between* every invocation
            </summary>
            <value>
                Default is 5 seconds
            </value>
        </member>
        <member name="P:Griffin.ApplicationServices.ApplicationServiceTimer.IsRunning">
            <summary>
                Returnerar <c>true</c> om tjänsten är uppe och snurrar.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.ApplicationServiceTimer.Failed">
            <summary>
            Service failed to execute.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.BackgroundJobFailedEventArgs">
            <summary>
                Failed to execute a job. 
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobFailedEventArgs.#ctor(System.Object,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.BackgroundJobFailedEventArgs"/> class.
            </summary>
            <param name="job">Job that failed (or <see cref="T:Griffin.ApplicationServices.BackgroundJobManager.NoJob"/> if the job could not be resolved in the container).</param>
            <param name="exception">Exception that the job threw.</param>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobFailedEventArgs.Job">
            <summary>
                Job that failed.
            </summary>
            <remarks>
            <para>An object which implements either <c>IBackgroundJob</c> or <c>IBackgroundJobAsync</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobFailedEventArgs.Exception">
            <summary>
                Exception that the job threw.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.BackgroundJobManager">
            <summary>
                Used to execute all classes that implement <see cref="T:Griffin.ApplicationServices.IBackgroundJob"/>. The jobs are executed in parallell.
            </summary>
            <remarks>
                <para>
                    This implementation uses your inversion of control container via the interface
                    <see cref="T:Griffin.Container.IContainer"/>.. A new scope (
                    <see cref="T:Griffin.Container.IContainerScope"/>
                    ) is created for every time a job is executed.
                </para>
                <para>
                    By subscribing on the event <see cref="E:Griffin.ApplicationServices.BackgroundJobManager.ScopeClosing"/> you can for instance commit an unit of work everytime a
                    job have been executed.
                </para>
                <para>
                    To be able to run every job in isolation (in an own scope) we need to be able to find all background jobs. To
                    do that a temporary scope
                    is created during startup to resolve all jobs (<c><![CDATA[scope.ResolveAll<IBackgroundJob>()]]></c>. The jobs
                    are not invoked but only located so that we can map all background job types. Then later
                    when we are going to execute each job we use <c><![CDATA[scope.Resolve(jobType)]]></c> for every job that is
                    about to be executed.
                </para>
            <para>
            The following signals are implemented (see <see cref="N:Griffin.Signals"/>):
            </para>
            <list type="bullet">
            <item>
            <term>ApplicationServices[fullTypeNameForServiceClass].Faulted</term>
            <description>Failed to execute job successfully.</description>
            </item>
            </list>
            </remarks>
            <example>
                <para>
                    Example for a windows service class:
                </para>
                <code>
            public class Service1 : ServiceBase
            {
                BackgroundJobManager _jobInvoker;
                IContainer  _container;
            
                public Service1()
                {
                    _serviceLocator = CreateContainer();
            
                    _jobInvoker = new BackgroundJobManager(_container);
                    _jobInvoker.ScopeClosing += OnScopeClosing;
                }
            
                public override OnStart(string[] argv)
                {
                    _jobInvoker.Start();
                }
            
                public override OnStop()
                {
                    _jobInvoker.Stop();
                }
            
                public void CreateContainer()
                {
                    // either create your container directly
                    // or use the composition root pattern.
                }
            
                // so that we can commit the transaction
                // event will not be invoked if something fails.
                public void OnScopeClosing(object sender, ScopeCreatedEventArgs e)
                {
                    <![CDATA[e.Scope.Resolve<IUnitOfWork>().SaveChanges();]]>
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.#ctor(Griffin.Container.IContainer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.BackgroundJobManager"/> class.
            </summary>
            <param name="container">The container.</param>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.Start">
            <summary>
                Start executing jobs (once the <see cref="P:Griffin.ApplicationServices.BackgroundJobManager.StartInterval"/> have been passed).
            </summary>
            <remarks>
                <para>
                    Will do one initial resolve on al jobs in the container to be able to discover their <c>Type</c>. Without this
                    check it would not be
                    possible to run each job in an isolated scope.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.Stop">
            <summary>
                Stop executing jobs.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobManager.StartInterval">
            <summary>
                Amount of time before running the jobs for the first time
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobManager.ExecuteInterval">
            <summary>
                Amount of time that should be passed between every execution run.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.BackgroundJobManager.ScopeCreated">
            <summary>
                A new scope has been created and the jobs are about to be executed.
            </summary>
        </member>
        <member name="E:Griffin.ApplicationServices.BackgroundJobManager.ScopeClosing">
            <summary>
                A job have finished executing.
            </summary>
            <remarks>
                <para>
                    Will not be invoked if <see cref="E:Griffin.ApplicationServices.BackgroundJobManager.JobFailed"/> event sets <c>CanContinue</c> to <c>false</c>.
                </para>
            </remarks>
        </member>
        <member name="E:Griffin.ApplicationServices.BackgroundJobManager.JobFailed">
            <summary>
                One of the jobs failed
            </summary>
            <remarks>
                Use this event to determine if the rest of the jobs should be able to execute.
            </remarks>
        </member>
        <member name="T:Griffin.ApplicationServices.BackgroundJobManager.NoJob">
            <summary>
            Used in the events when a job can not be constructed.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.IBackgroundJob">
            <summary>
                A background job which requires a lifetime scope (to access database connection/transaction etc).
            </summary>
            <example>
            <code>
            <![CDATA[
            [ContainerService]
            public class CleanUpOldFriendRequests : IBackgroundJob
            {
                private readonly IUnitOfWork _uow;
                private static DateTime _lastExecutionTime;
            
                public CleanUpOldFriendRequests(IUnitOfWork uow)
                {
                    if (uow == null) throw new ArgumentNullException("uow");
            
                    _uow = uow;
                }
            
                public void Execute()
                {
                    //run once a day
                    if (_lastExecutionTime.Date >= DateTime.Today)
                        return;
                    _lastExecutionTime = DateTime.Today;
            
                    using (var cmd = _uow.CreateCommand())
                    {
                        cmd.CommandText = "DELETE FROM FriendRequests WHERE CreatedAtUtc < @datum";
                        cmd.AddParameter("datum", DateTime.Today.AddDays(-10));
                        cmd.ExecuteNonQuery();
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.IBackgroundJob.Execute">
            <summary>
                Execute job
            </summary>
            <remarks>
                Any unhandled exceptions will be caught by the <see cref="T:Griffin.ApplicationServices.BackgroundJobManager"/>.
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.NoJob.#ctor(System.Type,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.BackgroundJobManager.NoJob"/> class.
            </summary>
            <param name="jobType">Type of the job.</param>
            <param name="exception">The exception.</param>
            <exception cref="T:System.ArgumentNullException">exception</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.NoJob.Execute">
            <summary>
                Exekvera jobbet.
            </summary>
            <remarks>
                Eventuella undantag hanteras av klassen som exekverar jobbet.
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.BackgroundJobManager.NoJob.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            <returns>
                A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobManager.NoJob.JobType">
            <summary>
            Job that could not be created
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.BackgroundJobManager.NoJob.Exception">
            <summary>
            Exception that prevents job from being created.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.IAppServiceLocator">
            <summary>
            Used to discover services.
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.IAppServiceLocator.GetServices">
            <summary>
            Discover all services for <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/>.
            </summary>
            <returns>Returned services are considered to be single instances, i.e. live as long as the application.</returns>
        </member>
        <member name="T:Griffin.ApplicationServices.IBackgroundJobAsync">
            <summary>
                A background job which requires a lifetime scope (to access database connection/transaction etc).
            </summary>
            <example>
            <code>
            <![CDATA[
            [ContainerService]
            public class CleanUpOldFriendRequests : IBackgroundJobAsync
            {
                private readonly IUnitOfWork _uow;
                private static DateTime _lastExecutionTime;
            
                public CleanUpOldFriendRequests(IUnitOfWork uow)
                {
                    if (uow == null) throw new ArgumentNullException("uow");
            
                    _uow = uow;
                }
            
                public async Task ExecuteAsync()
                {
                    //run once a day
                    if (_lastExecutionTime.Date >= DateTime.Today)
                        return;
                    _lastExecutionTime = DateTime.Today;
            
                    using (var cmd = _uow.CreateCommand())
                    {
                        cmd.CommandText = "DELETE FROM FriendRequests WHERE CreatedAtUtc < @datum";
                        cmd.AddParameter("datum", DateTime.Today.AddDays(-10));
                        await cmd.ExecuteNonQueryAsync();
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.ApplicationServices.IBackgroundJobAsync.ExecuteAsync">
            <summary>
                Execute job
            </summary>
            <remarks>
                Any unhandled exceptions will be caught by the <see cref="T:Griffin.ApplicationServices.BackgroundJobManager"/>.
            </remarks>
            <returns>Completion task</returns>
        </member>
        <member name="T:Griffin.ApplicationServices.IocAppServiceLocator">
            <summary>
                Uses your inversion of control container to locate services.
            </summary>
            <remarks>
                <para>
                    No need to use this class directly, simply pass the <see cref="T:Griffin.Container.IContainer"/> (i.e. your IoC adapter) to the
                    <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/> constructor.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.IocAppServiceLocator.#ctor(Griffin.Container.IContainer)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.IocAppServiceLocator"/> class.
            </summary>
            <param name="container">Used to resolve <see cref="T:Griffin.ApplicationServices.IApplicationService"/>.</param>
            <exception cref="T:System.ArgumentNullException">container</exception>
        </member>
        <member name="M:Griffin.ApplicationServices.IocAppServiceLocator.GetServices">
            <summary>
                Discover all services for <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/>.
            </summary>
            <returns>Returned services are considered to be single instances, i.e. live as long as the application.</returns>
        </member>
        <member name="T:Griffin.ApplicationServices.NamespaceDoc">
            <summary>
            Application services are used to manage long running services and background jobs in business applications.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.ScopeClosingEventArgs">
            <summary>
                Arg for <see cref="E:Griffin.ApplicationServices.BackgroundJobManager.ScopeClosing"/>
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ScopeClosingEventArgs.#ctor(Griffin.Container.IContainerScope,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ScopeClosingEventArgs"/> class.
            </summary>
            <param name="scope">scope that is being closed.</param>
            <param name="successful">job was executed successfully.</param>
            <exception cref="T:System.ArgumentNullException">scope</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.ScopeClosingEventArgs.Scope">
            <summary>
                Scope that this event is for.
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ScopeClosingEventArgs.Successful">
            <summary>
            Job was executed successfully
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.ScopeClosingEventArgs.Exception">
            <summary>
            Exception if <see cref="P:Griffin.ApplicationServices.ScopeClosingEventArgs.Successful"/> is false.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.ScopeCreatedEventArgs">
            <summary>
                Arg for  <see cref="E:Griffin.ApplicationServices.BackgroundJobManager.ScopeCreated"/>
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.ScopeCreatedEventArgs.#ctor(Griffin.Container.IContainerScope)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.ApplicationServices.ScopeCreatedEventArgs"/> class.
            </summary>
            <param name="scope">That that will be used to resolve job.</param>
            <exception cref="T:System.ArgumentNullException">scope</exception>
        </member>
        <member name="P:Griffin.ApplicationServices.ScopeCreatedEventArgs.Scope">
            <summary>
                Scope that this event is for.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.AppDomains.Host.AppInitializeRunner">
            <summary>
                Used to control the application within the new appdomain
            </summary>
            <remarks>
                <para>Runs inside the new app domain to be able to allow the <see cref="T:Griffin.ApplicationServices.AppDomains.Host.HostedAppDomain"/> to control it.</para>
                <para>
                    this class starts your <see cref="T:Griffin.ApplicationServices.AppDomains.IApplicationInitialize"/> inside the new appdomain to allow your
                    application to run.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.AppInitializeRunner.Start(System.String,System.String)">
            <summary>
            Start domain and the channel used for communication.
            </summary>
            <param name="pipeName">Pipe name</param>
            <param name="id">App id identifier</param>
        </member>
        <member name="M:Griffin.ApplicationServices.AppDomains.Host.AppInitializeRunner.StopService">
            <summary>
                Stop the running service.
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.StartServiceException">
            <summary>
                Failed to start a service.
            </summary>
            <seealso cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/>
        </member>
        <member name="M:Griffin.ApplicationServices.StartServiceException.#ctor(Griffin.ApplicationServices.IApplicationService,System.Exception)">
            <summary>
            </summary>
            <param name="service">Service that failed</param>
            <param name="exception">Exception which prevented the service from starting.</param>
        </member>
        <member name="P:Griffin.ApplicationServices.StartServiceException.Service">
            <summary>
                Gets service which could not be started
            </summary>
        </member>
        <member name="T:Griffin.BitConverter2">
            <summary>
            Missing <see cref="T:System.BitConverter"/> methods.
            </summary>
        </member>
        <member name="M:Griffin.BitConverter2.GetBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the int into the pre-allocated buffer.
            </summary>
            <param name="value">The value.</param>
            <param name="destination">The destination.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:Griffin.BitConverter2.GetBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copes the short into the pre-allocated buffer
            </summary>
            <param name="value">The value.</param>
            <param name="destination">The destination.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="T:Griffin.ConstructorExtensions">
            <summary>
                Credits http://rogeralsing.com/2008/02/28/linq-expressions-creating-objects/
            </summary>
        </member>
        <member name="M:Griffin.ConstructorExtensions.CreateFactory(System.Reflection.ConstructorInfo)">
            <summary>
                Creates a delegate which allocates a new object faster than  <see cref="M:System.Activator.CreateInstance``1"/>.
            </summary>
            <param name="ctor">The ctor.</param>
            <returns>The activator</returns>
            <remarks>
                The method uses an expression tree to build
                a delegate for the specified constructor
            </remarks>
        </member>
        <member name="T:Griffin.Container.ContainerLifetime">
            <summary>
            Defines which lifetime a service implementation should have in the inversion of control container
            </summary>
            <seealso cref="T:Griffin.Container.ContainerServiceAttribute"/>
        </member>
        <member name="F:Griffin.Container.ContainerLifetime.Scoped">
            <summary>
            Scoped, i.e. will be diposed when the child container is disposed.
            </summary>
        </member>
        <member name="F:Griffin.Container.ContainerLifetime.SingleInstance">
            <summary>
            Same instance should be used for all retrievals.
            </summary>
        </member>
        <member name="F:Griffin.Container.ContainerLifetime.Transient">
            <summary>
            Return a new instance every time
            </summary>
        </member>
        <member name="T:Griffin.Container.ContainerServiceAttribute">
            <summary>
                Used to simplify registration of services in an inversion of control container.
            </summary>
            <remarks>
                <para>
                    The purpose of this attribute is to allow services to be registered in containers without having to specify a <c>Register()</c> line for every class that should exist in the service. You
            can instead tag every class with this attribute and then let the container scan all assemblies after classes that have this attribute. We have built support for that in every container adaper that we've written. The extension methods
            are called <c>RegisterServices()</c>.
                </para>
                <para>
                    The methods that does registrations with the help of this attribute should register the class as all implemented interfaces except those that exist in the core .NET framework. If the class do not implement
            an interface it should be registered as itself.
                </para>
            </remarks>
            <example>
                <para>Example class that should be registered:</para>
                <code>
            [ContainerService]
            public class UserRepository : IRepository
            {
                IDbConnection _connection;
            
                public UserRepository(IDbConnection connection)
                {
                    if (connection == null) throw new ArgumentNullException("connection");
            
                    _connection = connection;
                }
            }
            </code>
            <para>
            If we use the autofac package <c>Griffin.Framework.Autofac</c> we can register it as:
            <code>
            var builder = new ContainerBuilder();
            
            // find all classes in the specified assembly
            builder.RegisterServices(Assembly.GetExecutingAssembly());
            
            var container = builder.Build();
            </code>
            </para>
            </example>
        </member>
        <member name="M:Griffin.Container.ContainerServiceAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Container.ContainerServiceAttribute"/> class.
            </summary>
            <remarks>
            <para>
            Lifetime is per default <c>ContainerLifetime.Scoped</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.ContainerServiceAttribute.#ctor(Griffin.Container.ContainerLifetime)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Container.ContainerServiceAttribute"/> class.
            </summary>
            <param name="lifetime">how long the object should live in the container..</param>
        </member>
        <member name="P:Griffin.Container.ContainerServiceAttribute.Lifetime">
            <summary>
                Gets specified lifetime
            </summary>
            <value>
            Lifetime is per default <c>ContainerLifetime.Scoped</c> unless otherwise specified in the constructor.
            </value>
        </member>
        <member name="T:Griffin.Container.IScopedTaskInvoker">
            <summary>
                Run an IoC registered service that requires a scope.
            </summary>
            <remarks>
                <para>
                    When you run singleton services you might need to be able to invoke scoped tasks. This
                    contract abstracts away the creation/deletion of custom scopes, thus a hard dependency towards
                    the container.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.IScopedTaskInvoker.Execute``1(System.Action{``0})">
            <summary>
                Run a task on a service
            </summary>
            <typeparam name="TService">Scoped Service to run a task on</typeparam>
            <param name="task">Task to execute</param>
            <example>
                <code>
            <![CDATA[
            _invoker.Execute<IUserRepository>(repos => repos.Save(model.User));
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Container.IScopedTaskInvoker.Execute``1(System.Action{``0},System.Action{Griffin.Container.IContainerScope})">
            <summary>
                Run a task on a service
            </summary>
            <typeparam name="TService">Scoped Service to run a task on</typeparam>
            <param name="task">Task to execute</param>
            <param name="scope">Scope that was create it. Use it to commit an Unit Of Work etc.</param>
            <example>
                <code>
            <![CDATA[
            _invoker.Execute<IUserRepository>(
                repos => repos.Save(model.User),
                scope => scope.Resolve<IUnitOfWork>().SaveChanges()
            );
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Container.NamespaceDoc">
            <summary>
            Interfaces defining what an inversion of control container should expose.
            </summary>
        </member>
        <member name="T:Griffin.Container.ScopedTaskEventArgs">
            <summary>
                Event args for <see cref="E:Griffin.Container.ScopedTaskInvoker.TaskExecuted"/>.
            </summary>
        </member>
        <member name="M:Griffin.Container.ScopedTaskEventArgs.#ctor(System.Object,Griffin.Container.IContainerScope)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Container.ScopedTaskEventArgs"/> class.
            </summary>
            <param name="taskService">The task service.</param>
            <param name="scope">The scope.</param>
            <exception cref="T:System.ArgumentNullException">
                taskService
                or
                scope
            </exception>
        </member>
        <member name="P:Griffin.Container.ScopedTaskEventArgs.TaskService">
            <summary>
                Service that the task was executed in.
            </summary>
        </member>
        <member name="P:Griffin.Container.ScopedTaskEventArgs.Scope">
            <summary>
                Scope used to service the service.
            </summary>
        </member>
        <member name="T:Griffin.Container.ScopedTaskInvoker">
            <summary>
                Default implementation of <see cref="T:Griffin.Container.IScopedTaskInvoker"/>
            </summary>
        </member>
        <member name="M:Griffin.Container.ScopedTaskInvoker.#ctor(Griffin.Container.IContainer)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.ScopedTaskInvoker"/> class.
            </summary>
            <param name="container">The container adapter. Use for instance the GriffinFramework.Autofac package or implement the interface yourself.</param>
            <exception cref="T:System.ArgumentNullException">container</exception>
        </member>
        <member name="M:Griffin.Container.ScopedTaskInvoker.Execute``1(System.Action{``0})">
            <summary>
                Run a task on a service
            </summary>
            <typeparam name="TService">Scoped Service to run a task on</typeparam>
            <param name="task">Task to execute</param>
            <example>
                <code>
            <![CDATA[
            _invoker.Execute<IUserRepository>(repos => repos.Save(model.User));
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Container.ScopedTaskInvoker.Execute``1(System.Action{``0},System.Action{Griffin.Container.IContainerScope})">
            <summary>
                Run a task on a service
            </summary>
            <typeparam name="TService">Scoped Service to run a task on</typeparam>
            <param name="task">Task to execute</param>
            <param name="scopeTask">Scope that was created. Use it to commit an Unit Of Work etc.</param>
            <example>
                <code>
            <![CDATA[
            _invoker.Execute<IUserRepository>(
                repos => repos.Save(model.User),
                scope => scope.Resolve<IUnitOfWork>().SaveChanges()
            );
            ]]>
            </code>
            </example>
        </member>
        <member name="E:Griffin.Container.ScopedTaskInvoker.TaskExecuted">
            <summary>
                Called in each scope before closing it (upon successful completion).
            </summary>
        </member>
        <member name="T:Griffin.Container.ServiceNotRegisteredException">
            <summary>
                The requested service has not been registerd.
            </summary>
        </member>
        <member name="M:Griffin.Container.ServiceNotRegisteredException.#ctor(System.Type,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.ServiceNotRegisteredException"/> class.
            </summary>
            <param name="serviceType">Service that was not registered in the container.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Griffin.Container.ServiceNotRegisteredException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.ServiceNotRegisteredException"/> class.
            </summary>
            <param name="serviceType">Service that was not registered in the container.</param>
        </member>
        <member name="M:Griffin.Container.ServiceNotRegisteredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.ServiceNotRegisteredException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Griffin.Container.ServiceNotRegisteredException.ServiceType">
            <summary>
                Gets services that was requested
            </summary>
        </member>
        <member name="T:Griffin.Container.DependencyMissingException">
            <summary>
            A dependency was missing when we tried to resolve a service.
            </summary>
            <remarks>
            <para>
            Thrown when the requested service can be found, but one of the dependencies that the implementation of the service has is missing.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.DependencyMissingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.DependencyMissingException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Griffin.Container.IContainer">
            <summary>
                Contract for an inversion of control container
            </summary>
        </member>
        <member name="M:Griffin.Container.IContainer.Resolve``1">
            <summary>
                Resolve the last registered implementation for a service.
            </summary>
            <typeparam name="TService">Service that we want to get an implementation for</typeparam>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.Resolve(System.Type)">
            <summary>
                Resolve the last registered implementation for a service.
            </summary>
            <param name="service">Service that we want to get an implementation for.</param>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.ResolveAll``1">
            <summary>
                Resolve all implementations for a service.
            </summary>
            <typeparam name="TService">Service that we want to get an implementation(s) for</typeparam>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.ResolveAll(System.Type)">
            <summary>
                Resolve all implementations for a service.
            </summary>
            <param name="service">Service that we want to get an implementation(s) for</param>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.CreateScope">
            <summary>
                Created a child scope (i.e. a container with a lifetime that you control. Dispose the scope to clean up all
                resolved services).
            </summary>
            <returns>A child container (i.e. a lifetime scope)</returns>
        </member>
        <member name="T:Griffin.Container.IContainerScope">
            <summary>
            Represents a container with a limited lifetime.
            </summary>
            <remarks>
            <para>
            A child container stores all scoped objects in a list and will dispose all resolved objects when the scope is being disposed.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.IContainerScope.Resolve``1">
            <summary>
                Resolve the last registered implementation of a service.
            </summary>
            <typeparam name="TService">Service that we want to get an implementation for</typeparam>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.Resolve(System.Type)">
            <summary>
                Resolve the last registered implementation of a service.
            </summary>
            <param name="service">Service that we want to get an implementation for.</param>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
            <exception cref="T:System.ArgumentNullException">service</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.ResolveAll``1">
            <summary>
                Resolve all implementations of a service.
            </summary>
            <typeparam name="TService">Service that we want to get an implementation(s) for</typeparam>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.ResolveAll(System.Type)">
            <summary>
                Resolve all implementations of a service.
            </summary>
            <param name="service">Service that we want to get an implementation(s) for</param>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
            <exception cref="T:System.ArgumentNullException">service</exception>
        </member>
        <member name="T:Griffin.Data.AdoNetUnitOfWork">
            <summary>
                An unit of work implementation which uses the interfaces that is defined in ADO.NET and should therefore work with
                most ADO.NET driver implementations.
            </summary>
            <example>
                <code>
            public IUnitOfWork Create()
            {
                var conString = ConfigurationManager.ConnectionStrings("MyDb").ConnectionString;
                var con = new SqlConnection(conString);
                con.Open();
                return new AdoNetUnitOfWork(con, true);
            }
            
            UnitOfWorkFactory.SetFactoryMethod(() => Create());
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.IAdoNetUnitOfWork">
            <summary>
                ADO.NET features for a Unit Of Work
            </summary>
        </member>
        <member name="T:Griffin.Data.IUnitOfWork">
            <summary>
            Unit of work contract
            </summary>
            <remarks>
            <para>
            Disposing without <c>SaveChanges()</c> being called means that the transaction should be aborted.
            </para>
            </remarks>
            <example>
            <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var repos = new UserRepository(uow);
                repos.Create(user);
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.IUnitOfWork.SaveChanges">
            <summary>
            Commit changes.
            </summary>
            <exception cref="T:Griffin.Data.TransactionAlreadyClosedException">UoW have already been saved.</exception>
        </member>
        <member name="M:Griffin.Data.IAdoNetUnitOfWork.CreateCommand">
            <summary>
                Create a new command
            </summary>
            <returns>Created command (never <c>null</c>)</returns>
            <remarks>
                <para>The created command have been enlisted in the local transaction which is wrapped by this Unit Of Work.</para>
            </remarks>
            <exception cref="T:System.Data.DataException">Failed to create the command</exception>
        </member>
        <member name="M:Griffin.Data.IAdoNetUnitOfWork.Execute(System.String,System.Object)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection,System.Boolean)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
            <param name="ownsConnection">This unit of work owns the connection and will close it when being disposed.</param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection,System.Boolean,System.Data.IsolationLevel)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
            <param name="ownsConnection">This unit of work owns the connection and will close it when being disposed.</param>
            <param name="isolationLevel">Isolation level that the transaction should use.</param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.SaveChanges">
            <summary>
                Commit changes.
            </summary>
            <exception cref="T:Griffin.Data.TransactionAlreadyClosedException">Transaction have already been commited or disposed.</exception>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.CreateCommand">
            <summary>
                Create a new command
            </summary>
            <returns>Created command (never <c>null</c>)</returns>
            <remarks>
                <para>The created command have been enlisted in the local transaction which is wrapped by this Unit Of Work.</para>
            </remarks>
            <exception cref="T:System.Data.DataException">Failed to create the command</exception>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Execute(System.String,System.Object)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Execute(System.String)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
        </member>
        <member name="T:Griffin.Data.CommandExtensions">
            <summary>
            Extensions for IDbCommand
            </summary>
        </member>
        <member name="M:Griffin.Data.CommandExtensions.AddParameter(System.Data.IDbCommand,System.String,System.Object)">
            <summary>
                Add a parameter to a command
            </summary>
            <param name="command">Command to add parameter to</param>
            <param name="name">Name of the parameter</param>
            <param name="value">Value (will be changed to <c>DBNull.Value</c> automatically if it's <c>null</c>).</param>
            <returns>Created parameter</returns>
            <example>
                <code>
            using (var command = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT avg(Age) FROM Users WHERE LastName Like @name";
                cmd.AddParameter("name", "F%");
                return (int)cmd.ExecuteScalar();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.CommandExtensions.CreateDataException(System.Data.IDbCommand,System.Exception)">
            <summary>
            Creates a <c>DataException</c> using the command text and sql parameters.
            </summary>
            <param name="cmd">Command to build an exception from.</param>
            <param name="inner">Inner exception.</param>
            <returns>Created exception</returns>
        </member>
        <member name="T:Griffin.Data.EntityNotFoundException">
            <summary>
                Thrown when a method which expects to find an entity doesn't.
            </summary>
            <remarks>
            <para>this error message will always include information to be able to identify the missing entity.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.EntityNotFoundException.#ctor(System.String,System.Data.IDbCommand)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.EntityNotFoundException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="command">The command that was executed to find an entity.</param>
            <exception cref="T:System.ArgumentNullException">command</exception>
        </member>
        <member name="M:Griffin.Data.EntityNotFoundException.#ctor(System.String,System.Data.IDbCommand,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.EntityNotFoundException"/> class.
            </summary>
            <param name="description">The description.</param>
            <param name="command">The command.</param>
            <param name="inner">The inner.</param>
            <exception cref="T:System.ArgumentNullException">
            description
            or
            inner
            </exception>
        </member>
        <member name="M:Griffin.Data.EntityNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.EntityNotFoundException"/> class.
            </summary>
            <param name="info">The data necessary to serialize or deserialize an object.</param>
            <param name="context">Description of the source and destination of the specified serialized stream.</param>
        </member>
        <member name="M:Griffin.Data.EntityNotFoundException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown. </param><param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param><exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic). </exception><filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/></PermissionSet>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.Message">
            <summary>
                Gets a message that describes the current exception.
            </summary>
            <returns>
                The error message that explains the reason for the exception, or an empty string("").
            </returns>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.CommandText">
            <summary>
            Gets command that was executed
            </summary>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.CommandParameters">
            <summary>
            The command parameter collection joined as a string
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.AdoNetEntityEnumerable`1">
            <summary>
            Wrapper around the <see cref="T:Griffin.Data.Mapper.AdoNetEntityEnumerator`1"/> which does the actual work.
            </summary>
            <typeparam name="TEntity">Type of entity to convert the rows to</typeparam>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerable`1.#ctor(System.Data.IDbCommand,System.Data.IDataReader,Griffin.Data.Mapper.IEntityMapper{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.AdoNetEntityEnumerable`1"/> class.
            </summary>
            <param name="command">The command.</param>
            <param name="reader">The reader.</param>
            <param name="mapper">The mapper.</param>
            <param name="ownsConnection">if set to <c>true</c> [owns connection].</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            reader
            or
            mapper
            </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">May only traverse AdoNetEntityEnumerable once</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Griffin.Data.Mapper.AdoNetEntityEnumerator`1">
            <summary>
                Traverses a recordset returned from a <c>IDbCommand</c> and converts each row to an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to convert to.</typeparam>
            <remarks>
                <para>
                    Will not do any conversions until the <see cref="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Current"/> property is being called. Hence you can call the
                    <see cref="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.MoveNext"/>
                    method any amount of times that you need without the mapping being used.
                </para>
                <para></para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.#ctor(System.Data.IDbCommand,System.Data.IDataReader,Griffin.Data.Mapper.IEntityMapper,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.AdoNetEntityEnumerator`1"/> class.
            </summary>
            <param name="command">The command.</param>
            <param name="reader">The reader.</param>
            <param name="mapper">The mapper.</param>
            <param name="ownsConnection">if set to <c>true</c> [owns connection].</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            reader
            or
            mapper
            </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.MoveNext">
            <summary>
                Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
                true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of
                the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Reset">
            <summary>
                Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Current">
            <summary>
                Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
                The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
                Gets the current element in the collection.
            </summary>
            <returns>
                The current element in the collection.
            </returns>
        </member>
        <member name="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider">
            <summary>
                Scans all assemblies in the current <c>AppDomain</c> after types that implement <see cref="T:Griffin.Data.Mapper.ICrudEntityMapper"/>.
            </summary>
            <remarks>
                <para>
                    All mappers are added as created instances to an internal cache for fast access during mapping operations.
                    Hence it's important
                    that they are thread safe and considered as singletons when this class is used.
                </para>
                <para>
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.IMappingProvider">
            <summary>
            Used by the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.IMappingProvider.Get``1">
            <summary>
                Retrieve a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to retrieve a mapper for.</typeparam>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
            <remarks>
            <para>
            Do note that the mapper must implement <see cref="T:Griffin.Data.Mapper.ICrudEntityMapper`1"/> interface for this method to work.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IMappingProvider.GetBase``1">
            <summary>
            Get mapping for the specified entity type
            </summary>
            <typeparam name="T">Type of entity</typeparam>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Get``1">
            <summary>
                Retrieve a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to retrieve a mapper for.</typeparam>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
            <remarks>
                <para>
                    Do note that the mapper must implement <see cref="T:Griffin.Data.Mapper.ICrudEntityMapper`1"/> interface for this method to work.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.GetBase``1">
            <summary>
                Get mapping for the specified entity type
            </summary>
            <typeparam name="TEntity">Type of entity</typeparam>
            <returns>Mapper</returns>
            <exception cref="T:System.NotSupportedException">The specified entity type is not supported.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Get(System.Type)">
            <summary>
                Retrieve a mapper.
            </summary>
            <param name="entityType">Type of entity to get a mapper for</param>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Scan">
            <summary>
                Scan all loaded assemblies in the current domain.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Scan(System.Reflection.Assembly)">
            <summary>
                Scan all loaded assemblies in the current domain.
            </summary>
            <param name="assembly">Assembly to scan for types that implement <see cref="T:Griffin.Data.Mapper.ICrudEntityMapper"/>.,</param>
        </member>
        <member name="P:Griffin.Data.Mapper.AssemblyScanningMappingProvider.IgnoreInvalidMappers">
            <summary>
                Ignore mapper classes which are invalid when locating all mappings in the loaded assemblies.
            </summary>
            <remarks>
                <para>The <c>Scan()</c> method </para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.AssemblyScanningMappingProvider.ReplaceDuplicateMappers">
            <summary>
                If <c>true</c>, we'll replace the first mapper if we encounter a second mapper for the same entity.
            </summary>
            <remarks>
                <para>
                    <c>false</c> means that an exception will be thrown
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.AssemblyScanningMappingProvider.HasScanned">
            <summary>
                Scan has been called.
            </summary>
            <remarks>
                <para>
                    Used by the library to check if the library should trigger a scan.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncCommandExtensions">
            <summary>
                Asynchronous extensions for <see cref="T:System.Data.Common.DbCommand"/>.
            </summary>
            <remarks>
                <para>
                    All methods which do not take a mapper class uses the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to identify the
                    mapper to use when converting to/from rows in the database. SQL commands
                    for CRUD operations are provided by a <see cref="T:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder"/> implementation (specific for each database
                    engine).
                </para>
                <para>
                    CRUD operations are typically performed on the <see cref="T:Griffin.Data.IAdoNetUnitOfWork"/> or <see cref="T:System.Data.IDbConnection"/>
                    instead as you do not have to create your own command then.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstAsync``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first found entity asynchronously
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>
                entity
            </returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find specified entity.</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
                <para>
                    Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstAsync<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstAsync``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first found entity asynchronously
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper"></param>
            <returns>
                entity
            </returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstAsync<User>(new MyCustomMapper());
                }
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Griffin.Data.Mapper.CrudEntityMapper`1"/>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstOrDefaultAsync``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first row if found.
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstOrDefaultAsync<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstOrDefaultAsync``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first row if found.
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper">Mapper used to convert rows to entities</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstOrDefaultAsync<User>(new MyCustomMapping());
                }
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Griffin.Data.Mapper.CrudEntityMapper`1"/>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.IDbCommand)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var users = await cmd.ToEnumerable<User>();
                return users.Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returned from the query is all records that you want it's probably more efficient to use
                    <see cref="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.IDbCommand)"/>.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.IDbCommand,System.Boolean)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.IDbCommand,System.Boolean,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapper">Mapper used to convert rows to entities</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    Requires that a <c><![CDATA[IEntityMapper<TEntity>]]></c> is registered in the
                    <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.IDbCommand)">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    Uses the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct base mapper.
                </para>
                <para>
                    Make sure that you <c>await</c> the method, as nothing the reader is not disposed directly if you don't.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper">Mapper to use when converting rows to entities</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    Make sure that you <c>await</c> the method, as nothing the reader is not disposed directly if you don't.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncConnectionExtensions">
            <summary>
            Asynchronous extensions for database connections
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstOrDefaultAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstOrDefaultAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstOrDefaultAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstOrDefaultAsync``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstOrDefaultAsync<User>("WHERE age < @Age", new { Age = minAge });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">connection to load entity from</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstAsync``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">connection to load entity from</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstAsync<User>("WHERE id = @id", new { id = UserId });
            }
            ]]>
            </code>
            <para>
            Which will translate into:
            </para>
            <code>
            command.CommandText = "SELECT * FROM Users WHERE id = @id";
            var p = command.CreateParameter();
            p.Name = "id";
            p.Value = userId;
            command.Parameters.Add(p);
            </code>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.InsertAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Insert an entity into the database
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to use</param>
            <param name="entity">Entity to insert.</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.UpdateAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Update an existing entity
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to use</param>
            <param name="entity">Entity to update.</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.DeleteAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Delete an entity
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">DB connection.</param>
            <param name="entity">Entity to remove.</param>
            <returns>Task to wait on for completion.</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.DeleteAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">DB connection.</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Task to wait on for completion.</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                await connection.DeleteAsync(new { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ExecuteNonQueryAsync(System.Data.IDbConnection,System.String,System.Object)">
            <summary>
            Execute a query directly
            </summary>
            <param name="connection">Connection to execute query on</param>
            <param name="sql">sql query</param>
            <param name="parameters">parameters used in the query</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
            <para>Do note that the query must be using table column names and not class properties. No mapping is being made.</para>
            <para><c>null</c> is automatically replaced by <c>DBNull.Value</c> for the parameters</para>
            </remarks>
            <example>
            <code>
            public async Task Execute(IDbConnection connection)
            {
                connection.ExecuteNonQueryAsync("UPDATE Users SET Discount = Discount + 10 WHERE OrganizationId = @orgId", new { orgId = 10});
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ToEnumerableAsync``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row (you must close the connection once done).
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await connection.ToEnumerable<User>("Age < 10");
            var users = await connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await connection.ToEnumerable<User>("FirstName = @name", new { name = user.FirstName });
            var users = await connection.ToEnumerable<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ToEnumerableAsync``1(System.Data.IDbConnection,System.Boolean,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="query">Query or short query (<c>"id = @1"</c>)</param>
            <param name="parameters"></param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await connection.ToEnumerable<User>(true, "Age < 10");
            var users = await connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = 37");
            var users = await connection.ToEnumerable<User>(true, "FirstName = @name", new { name = user.FirstName });
            var users = await connection.ToEnumerable<User>(true, "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ToEnumerableAsync``1(System.Data.IDbConnection,System.Boolean,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapping">Mapping used when translating table rows to .NET classes.</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "Age < 10");
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = 37");
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @name", new { name = user.FirstName });
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ToListAsync``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await connection.ToListAsync<User>("Age < 10");
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await connection.ToListAsync<User>("FirstName = @name", new { name = user.FirstName });
            var users = await connection.ToListAsync<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ToListAsync``1(System.Data.IDbConnection,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="mapping">Mapping used to translate from db table rows to .NET object</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await connection.ToListAsync<User>("Age < 10");
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await connection.ToListAsync<User>("FirstName = @name", new { name = user.FirstName });
            var users = await connection.ToListAsync<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await connection.ToListAsync<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions">
            <summary>
                Extension methods for our AdoNet unit of work.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.DeleteAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
                DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">
                Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>
                .
            </typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="entity">Uses the primary key column(s), as defined in the mapping, to remove the entry.</param>
            <returns>Task to wait on for completion.</returns>
            <example>
                <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                return await _unitOfWork.DeleteAsync(new User { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.DeleteAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
                DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">
                Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>
                .
            </typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="constraints">Constraints to be used. any field with '%' in the name will return in <c>LIKE</c> queries.</param>
            <returns>Task to wait on for completion.</returns>
            <example>
                <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                await _unitOfWork.DeleteAsync(new { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.FirstOrDefaultAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">UnitOfWork to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstOrDefaultAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstOrDefaultAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.FirstOrDefaultAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">UnitOfWork to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstOrDefaultAsync<User>("WHERE age < @Age", new { Age = minAge });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.FirstAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">UnitOfWork to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.FirstAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object)">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">UnitOfWork to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstAsync<User>("WHERE id = @id", new { id = UserId });
            }
            ]]>
            </code>
            <para>
            Which will translate into:
            </para>
            <code>
            command.CommandText = "SELECT * FROM Users WHERE id = @id";
            var p = command.CreateParameter();
            p.Name = "id";
            p.Value = userId;
            command.Parameters.Add(p);
            </code>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.InsertAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
                Insert a new row into the database.
            </summary>
            <typeparam name="TEntity">
                Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>
                .
            </typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="entity">entity to insert into the database.</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
                <para>
                    Will assign the PK value to the
                </para>
            </remarks>
            <example>
                <code>
            var user = new User(10, "Jonas");
            using (var uow = UnitOfWorkFactory.Create())
            {
                await uow.InsertAsync(user);
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.UpdateAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
                Update an entity
            </summary>
            <typeparam name="TEntity">
                Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>
                .
            </typeparam>
            <param name="unitOfWork">Transaction wrapper</param>
            <param name="entity">Entity to update</param>
            <returns>Task to wait on for completion</returns>
            <example>
                <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var user = await uow.FirstAsync(new { Id = 1 });
                user.State = AccountState.Banned;
                await uow.UpdateAsync(user);
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.ToEnumerableAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row (you must close the connection once done).
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await unitOfWork.ToEnumerable<User>("Age < 10");
            var users = await unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await unitOfWork.ToEnumerable<User>("FirstName = @name", new { name = user.FirstName });
            var users = await unitOfWork.ToEnumerable<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.ToEnumerableAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Boolean,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">UnitOfWork to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await unitOfWork.ToEnumerable<User>(true, "Age < 10");
            var users = await unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = 37");
            var users = await unitOfWork.ToEnumerable<User>(true, "FirstName = @name", new { name = user.FirstName });
            var users = await unitOfWork.ToEnumerable<User>(true, "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.ToEnumerableAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Boolean,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapping">Mapping used when translating table rows to .NET classes.</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "Age < 10");
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = 37");
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @name", new { name = user.FirstName });
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.ToListAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await unitOfWork.ToListAsync<User>("Age < 10");
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await unitOfWork.ToListAsync<User>("FirstName = @name", new { name = user.FirstName });
            var users = await unitOfWork.ToListAsync<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.ToListAsync``1(Griffin.Data.IAdoNetUnitOfWork,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReaderAsync()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="mapping">Mapping used to translate from db table rows to .NET object</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = await unitOfWork.ToListAsync<User>("Age < 10");
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = 37");
            var users = await unitOfWork.ToListAsync<User>("FirstName = @name", new { name = user.FirstName });
            var users = await unitOfWork.ToListAsync<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = await unitOfWork.ToListAsync<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilder">
            <summary>
            Base class for command builders
            </summary>
            <remarks>
            Creates SQL commands per the SQL92 standard. Inherit this class to customize different commands.
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder">
            <summary>
            Used to be able to adapt basic queries to the SQL dialetcs of each database engine.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.InsertCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute an INSERT INTO using the entity as data
            </summary>
            <param name="command">Command that will be executed after this method call.</param>
            <param name="entity">Entity specified; If possible, set the entity primary key value when done.</param>
            <remarks>
            <para>The command should not be executed in the implementation of this interface. </para>
            <para>You may however execute commads </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.UpdateCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute an UPDATE using the entity as data
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <param name="entity">Update is made on all properties but those specified as primary key (which is used in the WHERE clause)</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.DeleteCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute a DELETE statement
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <param name="entity">Only primary key properties are used in the WHERE clause</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Truncate all rows in a table
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <remarks>
            <para>Some dialects have a special command which can be used to DELETE all rows from a table, everyone else should just use a DELETE statement without a WHERE clause.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.Paging(System.Data.IDbCommand,System.Int32,System.Int32)">
            <summary>
            Modify SQL statement so that the result is paged.
            </summary>
            <param name="command">Command to modify</param>
            <param name="pageNumber">One based index</param>
            <param name="pageSize">Items per page.</param>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.ParameterPrefix">
            <summary>
            Gets prefix to use for data parameters (typically '@' or ':')
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.#ctor(Griffin.Data.Mapper.ICrudEntityMapper)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilder"/> class.
            </summary>
            <param name="mapper">The mapper.</param>
            <exception cref="T:System.ArgumentNullException">mapper</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.InsertCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Generate an insert command, should end with a command that returns the insert identity.
            </summary>
            <param name="command">Command to add the query to</param>
            <param name="entity">Entity to store</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            entity
            </exception>
            <exception cref="T:System.Data.DataException">No values were added to the query for  + entity</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.UpdateCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Create an update query from the entity.
            </summary>
            <param name="command">Command to modify</param>
            <param name="entity">Entity to update</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            entity
            </exception>
            <exception cref="T:System.Data.DataException">
            At least one property (other than primary keys) must be specified.
            or
            </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.DeleteCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute a DELETE statement
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <param name="entity">Only primary key properties are used in the WHERE clause</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            entity
            </exception>
            <exception cref="T:System.Data.DataException"></exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Truncate all rows in a table
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <exception cref="T:System.ArgumentNullException">command</exception>
            <remarks>
            Will do a DELETE statement
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.Paging(System.Data.IDbCommand,System.Int32,System.Int32)">
            <summary>
            Modify SQL statement so that the result is paged.
            </summary>
            <param name="command">Command to modify</param>
            <param name="pageNumber">One based index</param>
            <param name="pageSize">Items per page.</param>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.TableName">
            <summary>
            Gets table that the mapping is for
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.ParameterPrefix">
            <summary>
            Gets prefix to use for data parameters (typically '@' or ':')
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.Mapper">
            <summary>
            Mapper that this builder is for.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory">
            <summary>
            Used to produce factories of the correct 
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory.Assign(System.Func{Griffin.Data.Mapper.ICrudEntityMapper,Griffin.Data.Mapper.CommandBuilders.ICommandBuilder})">
            <summary>
            Assigns the specified command builder.
            </summary>
            <param name="commandBuilder">Assign your database engine specific command builder factory.</param>
            <exception cref="T:System.ArgumentNullException">commandBuilder</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory.Create(Griffin.Data.Mapper.ICrudEntityMapper)">
            <summary>
            Create a command builder that uses your DB engine dialect.
            </summary>
            <param name="mapper">Mapper to get a builder for.</param>
            <returns>builder.</returns>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.NamespaceDoc">
            <summary>
            Command builders are used to create standard SQL commands like CRUD and basic SELECTs. They exist to be able to adapt the
            commands for every RDBMS out there.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.PostgreSqlCommandBuilder">
            <summary>
            Will fetch the sequence value during inserts, truncate table (including the sequence) and page accordingly.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.PostgreSqlCommandBuilder.#ctor(Griffin.Data.Mapper.ICrudEntityMapper)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilder"/> class.
            </summary>
            <param name="mapper">The mapper.</param>
            <exception cref="T:System.ArgumentNullException">mapper</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.PostgreSqlCommandBuilder.InsertCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Generate an insert command, should end with a command that returns the insert identity.
            </summary>
            <param name="command">Command to add the query to</param>
            <param name="entity">Entity to store</param>
            <exception cref="T:System.ArgumentNullException">
            command
            or
            entity
            </exception>
            <exception cref="T:System.Data.DataException">No values were added to the query for  + entity</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.PostgreSqlCommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Truncate all rows in a table
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <exception cref="T:System.ArgumentNullException">command</exception>
            <remarks>
            Will do a DELETE statement
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.PostgreSqlCommandBuilder.Paging(System.Data.IDbCommand,System.Int32,System.Int32)">
            <summary>
            Uses LIMIT/OFFSET
            </summary>
            <param name="command">Command to modify</param>
            <param name="pageNumber">One based index</param>
            <param name="pageSize">Items per page.</param>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder">
            <summary>
            Specializations for Sql Server.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder.#ctor(Griffin.Data.Mapper.ICrudEntityMapper)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder"/> class.
            </summary>
            <param name="mapper">Mapper that this builder can generate queries for.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder.InsertCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Generate an insert command, should end with a command that returns the insert identity.
            </summary>
            <param name="command">Command to add the query to</param>
            <param name="entity">Entity to store</param>
            <remarks>
            Last statement will return @@identity. 
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Uses TRUNCATE TABLE
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <remarks>
            Will do a TRUNCATE TABLE statement
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder.Paging(System.Data.IDbCommand,System.Int32,System.Int32)">
            <summary>
            Uses the SQL Server 2012 syntax (OFFSET/FETCH NEXT)
            </summary>
            <param name="command">command to modify</param>
            <param name="pageNumber">One based index</param>
            <param name="pageSize">Items per page.</param>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandExtensions">
            <summary>
                Extensions for <see cref="T:System.Data.IDbCommand"/>.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ApplyConstraints``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.Object)">
            <summary>
            Takes an anonymous/dynamic objects and converts it into a WHERE clause using the supplied mapping.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to add parameters to (should end with " WHERE " so that this method can add the constraints properly)</param>
            <param name="mapper">Mapper to use to convert properties to columns</param>
            <param name="constraints">properties in an anonymous object</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
            Builds a command using query or a short-hand query, and query parameters.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to add parameters to (should end with " WHERE " so that this method can add the constraints properly)</param>
            <param name="mapper">Mapper to use to convert properties to columns</param>
            <param name="sql">Complete (<code>"SELECT * FROM user WHERE id = @id"</code>) or short (<code>"id = @id"</code>).</param>
            <param name="parameters">Anonymous object (<code>new { id = user.Id }</code>), a dictionary or an array of values</param>
            <remarks>
            <para>
            Query 
            </para>
            
            </remarks>
            <example>
            <para>Using complete query, with named arguments</para>
            <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    command.ApplyQuerySql("SELECT * FROM Users WHERE Id = @id", new { id = user.Id});
                    return cmd.First<User>();
                }
            }
            ]]>
            </code>
            <para>Using complete query, with array of values</para>
            <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    command.ApplyQuerySql("SELECT * FROM Users WHERE Id = @1", user.Id);
                    return cmd.First<User>();
                }
            }
            ]]>
            </code>
            <para>Using short query and named parameters</para>
            <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    command.ApplyQuerySql("Age <= @age AND City = @city", new { age = dto.Age, city = dto.City});
                    return cmd.ToList<User>();
                }
            }
            ]]>
            </code>
            <para>Using short query and a value array</para>
            <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    command.ApplyQuerySql("Age <= @1 AND City = @2", dto.Age, dto.City);
                    return cmd.First<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.First``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first row from a query, but mapped as an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Entity</returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.First<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.First``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0})">
            <summary>
                Fetches the first row from a query, but mapped as an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper which can convert the db row to an entity.</param>
            <returns>Entity</returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.First<User>(new MyCustomMapper());
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.FirstOrDefault``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first row and maps it as an entity (if found).
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Entity if found; otherwise <c>null</c>.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.FirstOrDefault<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.FirstOrDefault``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0})">
            <summary>
                Fetches the first row and maps it as an entity (if found).
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper which can convert the db row to an entity.</param>
            <returns>Entity if found; otherwise <c>null</c>.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.FirstOrDefault<User>(new MyCustomUserMapper());
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    Hence the different between this method and the <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>
                    method is
                    that this one do not create a list in the memory with all entities. It's therefore perfect if you want to
                    process a large amount
                    of rows.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand,System.Boolean)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var pagedUsers = cmd.ToEnumerable<User>().Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returnd from the query is all records that you want it's probably more effecient to use
                    <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand,System.Boolean,Griffin.Data.Mapper.ICrudEntityMapper{``0})">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapper">Mapper which convert a db row to an entity</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var pagedUsers = cmd.ToEnumerable<User>().Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returnd from the query is all records that you want it's probably more effecient to use
                    <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>A collection of entities, or an empty collection if no entities are found.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindByName(string firstName, string lastName)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE ";
                    if (lastName != null)
                    {
                        cmd.AddParameter("firstName", firstName + "%");
                        cmd.CommandText += "FirstName LIKE @firstName AND ";
                    }
                    if (lastName != null)
                    {
                        cmd.AddParameter("lastName", lastName + "%");
                        cmd.CommandText += "LastName LIKE @lastName AND ";
                    }
            
                    cmd.CommandText = cmd.CommandText.Remove(cmd.CommandText.Length - 4, 4);
                    return cmd.ToList<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0})">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper to use when converting the rows to entities</param>
            <returns>A collection of entities, or an empty collection if no entities are found.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindByName(string firstName, string lastName)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE ";
                    if (lastName != null)
                    {
                        cmd.AddParameter("firstName", firstName + "%");
                        cmd.CommandText += "FirstName LIKE @firstName AND ";
                    }
                    if (lastName != null)
                    {
                        cmd.AddParameter("lastName", lastName + "%");
                        cmd.CommandText += "LastName LIKE @lastName AND ";
                    }
            
                    cmd.CommandText = cmd.CommandText.Remove(cmd.CommandText.Length - 4, 4);
                    return cmd.ToList<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.ConnectionExtensions">
            <summary>
            Synchronous connection extensions.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.FirstOrDefault``1(System.Data.IDbConnection,System.Object)">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return _connection.FirstOrDefault<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return _connection.FirstOrDefault<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.FirstOrDefault``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return _connection.FirstOrDefault<User>("WHERE age < @Age", new { Age = minAge });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.First``1(System.Data.IDbConnection,System.Object)">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">connection to load entity from</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return _connection.First<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return _connection.First<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.First``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">connection to load entity from</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return _connection.First<User>("WHERE id = @id", new { id = UserId });
            }
            ]]>
            </code>
            <para>
            Which will translate into:
            </para>
            <code>
            command.CommandText = "SELECT * FROM Users WHERE id = @id";
            var p = command.CreateParameter();
            p.Name = "id";
            p.Value = userId;
            command.Parameters.Add(p);
            </code>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.CreateDbCommand(System.Data.IDbConnection)">
            <summary>
            Cast <c>IDbCommand</c> to <c>DbCommand</c> to be able to access the async methods.
            </summary>
            <param name="connection">Connection used as a factory</param>
            <returns>Command</returns>
            <exception cref="T:System.NotSupportedException">The created command cannot be cast to DbCommand.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Truncate``1(System.Data.IDbConnection)">
            <summary>
            Truncate a table (remove all rows)
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to create and execute our command on</param>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Insert``1(System.Data.IDbConnection,``0)">
            <summary>
            Insert a new row into the database.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection create and execute our command on.</param>
            <param name="entity">entity to insert into the database.</param>
            <remarks>
            <para>
            Will assign the PK value to the 
            </para>
            </remarks>
            <example>
            <code>
            var user = new User(10, "Jonas");
            connection.Insert(user);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Update``1(System.Data.IDbConnection,``0)">
            <summary>
            Update an entity
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Transaction wrapper</param>
            <param name="entity">Entity to update</param>
            <returns>Task to wait on for completion</returns>
            <example>
            <code>
            var user = connection.First(new { Id = 1 });
            user.State = AccountState.Banned;
            connection.Update(user);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Delete``1(System.Data.IDbConnection,``0)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Unit of work to execute command in.</param>
            <param name="entity">Uses the primary key column(s), as defined in the mapping, to remove the entry.</param>
            <example>
            <code>
            <![CDATA[
            public void DeleteUser(int userId)
            {
                connection.Delete(new User { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Delete``1(System.Data.IDbConnection,System.Object)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Unit of work to execute command in.</param>
            <param name="constraints"><c>dynamic</c> specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <example>
            <code>
            <![CDATA[
            public void DeleteUser(int userId)
            {
                connection.Delete(new { Id = userId });
            }
            ]]>
            </code>
            <para>Alternative syntax:</para>
            <code>
            <![CDATA[
            public void DeleteUser(SomeDTO dto)
            {
                connection.Delete(new { dto.Id });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ExecuteNonQuery(System.Data.IDbConnection,System.String,System.Object)">
            <summary>
            Execute a query directly
            </summary>
            <param name="connection">Connection to execute query on</param>
            <param name="sql">sql query</param>
            <param name="parameters">parameters used in the query</param>
            <remarks>
            <para>Do note that the query must be using table column names and not class properties. No mapping is being made.</para>
            <para><c>null</c> is automatically replaced by <c>DBNull.Value</c> for the parameters</para>
            </remarks>
            <example>
            <code>
            public void Execute(IDbConnection connection)
            {
                connection.ExecuteNonQuery("UPDATE Users SET Discount = Discount + 10 WHERE OrganizationId = @orgId", new { orgId = 10});
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ToEnumerable``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row (you must close the connection once done).
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = connection.ToEnumerable<User>("Age < 10");
            var users = connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = 37");
            var users = connection.ToEnumerable<User>("FirstName = @name", new { name = user.FirstName });
            var users = connection.ToEnumerable<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = connection.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ToEnumerable``1(System.Data.IDbConnection,System.Boolean,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="query">Query or short query (<c>"id = @1"</c>)</param>
            <param name="parameters"></param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = connection.ToEnumerable<User>(true, "Age < 10");
            var users = connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = 37");
            var users = connection.ToEnumerable<User>(true, "FirstName = @name", new { name = user.FirstName });
            var users = connection.ToEnumerable<User>(true, "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = connection.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ToEnumerable``1(System.Data.IDbConnection,System.Boolean,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapping">Mapping used when translating table rows to .NET classes.</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "Age < 10");
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = 37");
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @name", new { name = user.FirstName });
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = connection.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ToList``1(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = connection.ToList<User>("Age < 10");
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = 37");
            var users = connection.ToList<User>("FirstName = @name", new { name = user.FirstName });
            var users = connection.ToList<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ToList``1(System.Data.IDbConnection,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="connection">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="mapping">Mapping used to translate from db table rows to .NET object</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = connection.ToList<User>("Age < 10");
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = 37");
            var users = connection.ToList<User>("FirstName = @name", new { name = user.FirstName });
            var users = connection.ToList<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = connection.ToList<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.DateTimeExtensions">
            <summary>
            Some databases do not support DateTime columns. For them we can instead store an unix time integer. These extensions handles the conversions for us.
            </summary>
        </member>
        <member name="F:Griffin.Data.Mapper.DateTimeExtensions.UnixDate">
            <summary>
            Unix epoch time
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.TruncateMilliseconds(System.DateTime)">
            <summary>
            Will remove milliseconds from the the date tiime
            </summary>
            <param name="source">Time with milliseconds.</param>
            <returns>Date/Time without ms</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.ToUnixTime(System.DateTime)">
            <summary>
            Convert a date to unix epoch
            </summary>
            <param name="dateUtc">MUST be in UTC. Either use <c>DateTime.UtcNow</c> or convert the local time to UTC time.</param>
            <returns>Seconds from 1970-01-01</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.FromUnixTime(System.Double)">
            <summary>
            Convert unix time to a DateTime struct
            </summary>
            <param name="unixTime">Seconds from 1970-01-01</param>
            <returns>Date/time in UTC time zone</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.FromUnixTime(System.Int32)">
            <summary>
            Convert unix time to a DateTime struct
            </summary>
            <param name="unixTime">Seconds from 1970-01-01</param>
            <returns>Date/time in UTC time zone</returns>
        </member>
        <member name="T:Griffin.Data.Mapper.CrudEntityMapper`1">
            <summary>
                Uses reflection to map entities.
            </summary>
            <typeparam name="TEntity">Type of entity (i.e. class that somewhat corresponds to a table)</typeparam>
            <remarks>
                <para>
                    This mapper is conventional based. If there is a column named <c>"Id"</c> this mapper will assume that that is
                    the primary key. If you do not have
                    an <c>"Id"</c> id column you need to inherit this class and override the <c>Configure</c> method:
                </para>
                <code>
            <![CDATA[
            public class UserMapping : CrudEntityMapper<User>
            {
                public override void Configure(IDictionary<string, PropertyMapping> mappings)
                {
                    base.Configure(mappings);
            
                    mappings["YourCustomKey"].IsPrimaryKey = true;
                }
            }
            ]]>
            </code>
                <para>
                    All mappers must have a parameterless constructor, but you can set it as non-public if you do not want to
                    expose
                    it.
                </para>
                <para>
                </para>
            </remarks>
            <example>
                <para>
                    You can just create an empty class like below if there is an one-one mapping between the table and your entity
                    class. It will
                    automatically be
                    picked up by the <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/>.
                </para>
                <code>
            <![CDATA[
            public class UserMapping : CrudEntityMapper<User>
            {
            }
            ]]>
            </code>
                <para>You can also customize the mappings</para>
                <code>
            <![CDATA[
            public class UserMapping : CrudEntityMapper<User>
            {
                public override void Configure(IDictionary<string, PropertyMapping> mappings)
                {
                    base.Configure(mappings);
            
                    // Id is per default set to primary key, but any other name must be configured
                    // you can set multiple properties as a key too (composite key)
                    mappings["Id"].IsPrimaryKey = true;
            
                    // UserId is of the column type "uniqueidentifier" in the DB and of "string" type for our property.
                    mappings["UserId"].ColumnToPropertyAdapter = value => value.ToString();
                    mappings["UserId"].PropertyToColumnAdapter = value => Guid.Parse(string)value);
                }
            }
            ]]>
            </code>
                <para>Look at the <see cref="M:Griffin.Data.Mapper.EntityMapper`1.Configure(System.Collections.Generic.IDictionary{System.String,Griffin.Data.Mapper.IPropertyMapping})"/> documentation for more examples.</para>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.EntityMapper`1">
            <summary>
                Used to map a <see cref="T:System.Data.IDataRecord"/> to an entity.
            </summary>
            <remarks>
                <para>Just hides the non generic methods from the public contract.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.IEntityMapper`1">
            <summary>
            Generic version of the mapping method to make it easier to do mappings manually.
            </summary>
            <typeparam name="TEntity">Type of entity</typeparam>
            <remarks>
            <para>
            Important! The implementations of this interface should be considered to be singletons. Hence any state in them
            must be thread safe. The same instance can be used to map multiple entities at the same time.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            public class UserMapper : ICrudEntityMapper<User>
            {
                public object Create(IDataRecord source)
                {
                    return new User();
                }
            
                public void Map(IDataRecord source, User destination)
                {
                    destination.Id = source["Id"].ToString();
                    destination.Age = (int)source["Age"];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.IEntityMapper">
            <summary>
            Contract for only mapping rows and nothing more.
            </summary>
            <remarks>
            <para>
            Implementations of this class must be decorated with the <see cref="T:Griffin.Data.Mapper.MappingForAttribute"/> to allow <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/> to map it correctly.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.Create(System.Data.IDataRecord)">
            <summary>
            Create a new entity for the specified 
            </summary>
            <param name="record">should only be used to initialize any constructor arguments.</param>
            <returns>Created entity</returns>
            <example>
            <para>Where a default constructor exists:</para>
            <code>
            public object Create(IDataRecord record)
            {
                return new User();
            }
            </code>
            <para>Where a only constructors with arguments exists:</para>
            <code>
            public object Create(IDataRecord record)
            {
                return new User(record["Id"].ToString());
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.Map(System.Data.IDataRecord,System.Object)">
            <summary>
            Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
            <example>
            <code>
            public void Map(IDataRecord source, object destination)
            {
                var user = (User)destination;
                user.Id = source["Id"].ToString();
                user.Age = (int)source["Age"];
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper`1.Map(System.Data.IDataRecord,`0)">
            <summary>
            Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
            <example>
            <code>
            public void Map(IDataRecord source, User destination)
            {
                destination.Id = source["Id"].ToString();
                destination.Age = (int)source["Age"];
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.EntityMapper`1"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Griffin#Data#Mapper#IEntityMapper#Create(System.Data.IDataRecord)">
            <summary>
                Create a new entity for the specified
            </summary>
            <param name="record">Data record that we are going to map</param>
            <returns>Created entity</returns>
            <remarks>
                <para>
                    The provided record should only be used if there are constructor arguments.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Create(System.Data.IDataRecord)">
            <summary>
                Create a new entity for the specified
            </summary>
            <param name="record">Data record that we are going to map</param>
            <returns>Created entity</returns>
            <remarks>
                <para>
                    The provided record should only be used if there are constructor arguments.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Griffin#Data#Mapper#IEntityMapper#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Map(System.Data.IDataRecord,`0)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Configure(System.Collections.Generic.IDictionary{System.String,Griffin.Data.Mapper.IPropertyMapping})">
            <summary>
                Used to map all properties which should be read from the database record.
            </summary>
            <param name="mappings">Dictionary which should be filled with all mappings</param>
            <remarks>
                <para>
                    Will scan all properties and assign them a mapping, even if the setters are non-public. If no setter is
                    available
                    it will try to finding a field using the name convention where <c>FirstName</c> becomes <c>_firstName</c>.
                </para>
            </remarks>
            <example>
                <para>If you want to remove a property:</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings.Remove("CreatedAt");
            }
            ]]>
            </code>
                <para>Example if the column type is <c>uniqueidentifier</c> and the property type is string:</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["Id"].ColumnToPropertyAdapter = value => value.ToString();
            }
            ]]>
            </code>
                <para>If you have stored a child aggregate as a JSON string in a column</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["AuditLog"].ColumnToPropertyAdapter = value => JsonConvert.ToObject<IEnumerable<AuditEntry>>(value.ToString());
            }
            ]]>
            </code>
                <para>To convert an int column in the db to an enum</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["State"].ColumnToPropertyAdapter = value => (UserState)value;
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.CreateInstanceFactory">
            <summary>
                Generate a delegate which can create the entity blasingly fast (compared to <c>Activator.CreateInstance()</c>).
            </summary>
            <returns></returns>
            <exception cref="T:Griffin.Data.Mapper.MappingException">
                Failed to find a default constructor for ' + typeof
                (TEntity).FullName + '.
            </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Property``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
                Fluent syntax for defining a property mapping. Use in the constructor.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="propertyExpression">The property expression.</param>
            <returns>mapping to configure.</returns>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapper`1.Properties">
            <summary>
                All properties in this mapping
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.ICrudEntityMapper`1">
            <summary>
            Generic version of the mapping method to make it easier to do mappings manually.
            </summary>
            <typeparam name="TEntity">Type of entity</typeparam>
            <remarks>
            <para>
            Important! The implementations of this interface should be considered to be singletons. Hence any state in them
            must be thread safe. The same instance can be used to map multiple entities at the same time.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            public class UserMapper : ICrudEntityMapper<User>
            {
                public object Create(IDataRecord source)
                {
                    return new User();
                }
            
                public void Map(IDataRecord source, User destination)
                {
                    destination.Id = source["Id"].ToString();
                    destination.Age = (int)source["Age"];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.ICrudEntityMapper">
            <summary>
            Maps a table column to a .NET entity (to support CRUD operations).
            </summary>
            <remarks>
            <para>
            Important! The implementations of this interface should be considered to be singletons. Hence any state in them
            must be thread safe. The same instance can be used to map multiple entities at the same time.
            </para>
            <para>
            You have to decorate class that implement this interface with the <see cref="T:Griffin.Data.Mapper.MappingForAttribute"/> to tell the scanner
            which entity the class is a mapping for.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            [MappingFor(typeof(User))
            class UserMapper : ICrudEntityMapper<User>
            {
                public object Create(IDataRecord source)
                {
                    return new User();
                }
            
                public void Map(IDataRecord source, object destination)
                {
                    var user = (User)destination;
                    user.Id = source["Id"].ToString();
                    user.Age = (int)source["Age"];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ICrudEntityMapper.Freeze">
            <summary>
            Free the mapping, no further changes may be made.
            </summary>
            <remarks>
            <para>Called by the mapping provider when it's being added to it.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.ICrudEntityMapper.GetKeys(System.Object)">
            <summary>
            Get the primary key 
            </summary>
            <param name="entity">Entity to fetch key values from</param>
            <returns>A single item in the array for a single PK column and one entry per column in composite primary key</returns>
            <example>
            <para>If you have a single primary key (like an auto incremented column)</para>
            <code>
            <![CDATA[
            var user = new User { Id = 24, Name = "Jonas" };
            var mapping = new EntityMapping<User>();
            var pk = mapping.GetKeys(user);
            
            Console.WriteLine(pk[0].Name + " = " + pk[0].Value); // prints "Id = 24"
            ]]>
            </code>
            <para>
            A composite key:
            </para>
            <code>
            <![CDATA[
            var address = new UserAddress{ UserId = 24, ZipCode  = "1234", City = "Falun" };
            var mapping = new EntityMapping<UserAddress>();
            var pk = mapping.GetKeys(address);
            
            Console.WriteLine(pk[0].Value + ", " + pk[1].Value); // prints "24, 1234"
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Griffin.Data.Mapper.ICrudEntityMapper.TableName">
            <summary>
            Gets table name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.ICrudEntityMapper.Properties">
            <summary>
            All properties in this mapping
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.ICrudEntityMapper.CommandBuilder">
            <summary>
            Used to create SQL commands which is specific for this entity.
            </summary>
            <remarks>
            <para>The recommended approach for implementations is to retrieve the command builder from <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory"/> when the <c>Freeze()</c> method is being invoked.
            By doing so it's easy to adapt and precompile the command strings and logic before any invocations is made.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CrudEntityMapper`1.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.CrudEntityMapper`1"/> class.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CrudEntityMapper`1.Griffin#Data#Mapper#IEntityMapper#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CrudEntityMapper`1.Freeze">
            <summary>
                Free the mapping, no further changes may be made.
            </summary>
            <remarks>
                <para>Called by the mapping provider when the mapping have been added to it.</para>
                <para>
                    The purpose is to allow the mapping implementations to do post process once the mappings have been fully
                    configured. 
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CrudEntityMapper`1.GetKeys(System.Object)">
            <summary>
                Get the primary key
            </summary>
            <param name="entity">entity to fetch key values from.</param>
            <returns>A single item in the array for a single PK column and one entry per column in composite primary key</returns>
        </member>
        <member name="P:Griffin.Data.Mapper.CrudEntityMapper`1.TableName">
            <summary>
                Gets table name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.CrudEntityMapper`1.CommandBuilder">
            <summary>
                Used to create SQL commands which is specific for this entity.
            </summary>
            <remarks>
                <para>
                    The recommended approach for implementations is to retrieve the command builder from
                    <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory"/> when the <c>Freeze()</c> method is being invoked.
                    By doing so it's easy to adapt and precompile the command strings and logic before any invocations is made.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.EntityMappingProvider">
            <summary>
                Facade for the current <see cref="T:Griffin.Data.Mapper.IMappingProvider"/> implementation.
            </summary>
            <remarks>
                <para>
                    This facade exists so that no code needs to be refactored if the mapping provider is replace with another
                    one.
                </para>
                <para>
                    The <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/> is used per default (if no other provider is assigned). It
                    is lazy loaded so that
                    all assemblies have a chance to be loaded before it scans all assemblies in the current appdomain.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMappingProvider.GetMapper``1">
            <summary>
                Get a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to get a mapper for.</typeparam>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Did not find a mapper for the specified entity.</exception>
            <returns></returns>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMappingProvider.GetBaseMapper``1">
            <summary>
                Get a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to get a mapper for.</typeparam>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Did not find a mapper for the specified entity.</exception>
            <returns></returns>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMappingProvider.Provider">
            <summary>
                Provider to use.
            </summary>
            <value>
                Default is <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/>. Read the class remarks for more information.
            </value>
        </member>
        <member name="T:Griffin.Data.Mapper.FluentPropertyMapping`2">
            <summary>
                Used by <see cref="T:Griffin.Data.Mapper.EntityMapper`1"/>
            </summary>
            <typeparam name="TEntity">The type of the entity.</typeparam>
            <typeparam name="TPropertyType">Property type.</typeparam>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.#ctor(Griffin.Data.Mapper.PropertyMapping{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.FluentPropertyMapping`2"/> class.
            </summary>
            <param name="inner">Actual mapping object.</param>
            <exception cref="T:System.ArgumentNullException">inner</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.ColumnName(System.String)">
            <summary>
            Use if the column name differs from the property name
            </summary>
            <param name="columnName">Name of the column.</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentNullException">columnName</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.NotForQueries">
            <summary>
            Do not update property with the column value.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.NotForCrud">
            <summary>
            Do not write this property to the table.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.Ignore">
            <summary>
            Do not map this propery.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.PrimaryKey">
            <summary>
            Primary key (composite keys are supported).
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.PrimaryKey(System.Boolean)">
            <summary>
            Primary key (composite keys are supported).
            </summary>
            <param name="isAutoIncremented">Specified as a auto incremented (identity) field. i.e. the DB generates the value, do not specify the field in INSERT statements.</param>
            <returns>this</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.ToColumnValue(System.Func{`1,System.Object})">
            <summary>
            Use if the column type differs from the property type.
            </summary>
            <param name="fromPropertyConverter">From property converter.</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentNullException">fromPropertyConverter</exception>
            <remarks>
            <para>
            Used in CRUD statements
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.FluentPropertyMapping`2.ToPropertyValue(System.Func{System.Object,`1})">
            <summary>
            Use if the property type differs from the column type.
            </summary>
            <param name="fromColumnConverter">From column converter.</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentNullException">fromColumnConverter</exception>
            <remarks>
            <para>
            Used in <code>SELECT</code> statements.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.IPropertyMapping">
            <summary>
            Mapping for a class property
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
            <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.GetValue(System.Object)">
            <summary>
            Get property value
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <returns>Property value</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.SetColumnValue(System.Object,System.Object)">
            <summary>
            Set property value by specifying a column value (i.e. use the <c>ColumnToPropertyAdapter</c> when assigning the value)
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <param name="value">Column value</param>
            <returns>Property value</returns>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.CanWrite">
            <summary>
            Can write to property (i.e. update it from the table column)
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.CanRead">
            <summary>
            Can read from the property (i.e. create UPDATE/INSERT queries)
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.IsPrimaryKey">
            <summary>
            Used when fetching items
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.IsAutoIncrement">
            <summary>
            PK value is generated by the DB, i.e. do not insert it.
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.ColumnToPropertyAdapter">
            <summary>
                Used to convert the database value to the type used by the property
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.PropertyToColumnAdapter">
            <summary>
                Used to convert the property to the type used by the column.
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.PropertyName">
            <summary>
                Name of the property in the entity
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.ColumnName">
            <summary>
                Set if the column name is different from the property name
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.UnitOfWorkExtensions">
            <summary>
            Extension methods for the UnitOfWork.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.FirstOrDefault``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return unitOfWork.FirstOrDefault<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return unitOfWork.FirstOrDefault<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.FirstOrDefault``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return unitOfWork.FirstOrDefault<User>("WHERE age < @Age", new { Age = minAge });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.First``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return unitOfWork.First<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return unitOfWork.First<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.First``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
            Get an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Found entity</returns>
            <remarks>
            <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c></para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(int userId)
            {
                return unitOfWork.First<User>("WHERE id = @id", new { id = UserId });
            }
            ]]>
            </code>
            <para>
            Which will translate into:
            </para>
            <code>
            command.CommandText = "SELECT * FROM Users WHERE id = @id";
            var p = command.CreateParameter();
            p.Name = "id";
            p.Value = userId;
            command.Parameters.Add(p);
            </code>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.Truncate``1(Griffin.Data.IAdoNetUnitOfWork)">
            <summary>
            Truncate table (remove all rows without filling the transaction log)
            </summary>
            <typeparam name="TEntity">Type of entity (must have a mapping registred in the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>)</typeparam>
            <param name="unitOfWork">Uow to extend</param>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToList``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
            Find a collection of entities
            </summary>
            <typeparam name="TEntity">Type of entity (must have a mapping registred in the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>)</typeparam>
            <param name="unitOfWork">Uow to extend</param>
            <param name="parameters">The parameters.</param>
            <returns>Collection (can be empty if no entries are found)</returns>
            <example>
            <code>
            // will generate a SQL clause: WHERE FirstName Like 'A%' AND LastName LIKE 'B%'
            uow.First(new { FirstName = "A%", LastName = "B%" });
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.Insert``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            Insert a new item.
            </summary>
            <typeparam name="TEntity">Type of entity (must have a mapping registered in the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>)</typeparam>
            <param name="unitOfWork">Uow to extend</param>
            <param name="entity">The entity to create.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.Update``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            Update an existing entity
            </summary>
            <typeparam name="TEntity">Type of entity (must have a mapping registred in the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>)</typeparam>
            <param name="unitOfWork">Uow to extend</param>
            <param name="entity">The entity, must have the PK assigned.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.Delete``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            Delete an existing entity
            </summary>
            <typeparam name="TEntity">Type of entity (must have a mapping registred in the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>)</typeparam>
            <param name="unitOfWork">Uow to extend</param>
            <param name="entity">The entity, must have the PK assigned.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToEnumerable``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row (you must close the connection once done).
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToEnumerable<User>("Age < 10");
            var users = unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToEnumerable<User>("FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToEnumerable<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToEnumerable<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToEnumerable``1(Griffin.Data.IAdoNetUnitOfWork,System.Boolean,System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="query">Query or short query (<c>"id = @1"</c>)</param>
            <param name="parameters"></param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToEnumerable<User>(true, "Age < 10");
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToEnumerable<User>(true, "FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToEnumerable<User>(true, "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToEnumerable``1(Griffin.Data.IAdoNetUnitOfWork,System.Boolean)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToEnumerable<User>(true, "Age < 10");
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToEnumerable<User>(true, "FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToEnumerable<User>(true, "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToEnumerable<User>(true, "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToEnumerable``1(Griffin.Data.IAdoNetUnitOfWork,System.Boolean,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapping">Mapping used when translating table rows to .NET classes.</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "Age < 10");
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToEnumerable<User>(true, new CustomUserMapping(), "SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToList``1(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[ICrudEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToList<User>("Age < 10");
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToList<User>("FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToList<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.UnitOfWorkExtensions.ToList``1(Griffin.Data.IAdoNetUnitOfWork,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="unitOfWork">Connection to invoke <c>ExecuteReader()</c> on (through a created <c>DbCommand</c>).</param>
            <param name="mapping">Mapping used to translate from db table rows to .NET object</param>
            <param name="query">Query or short query (<c><![CDATA["projectId = @id AND dateCreated < @minDate"]]></c>)</param>
            <param name="parameters">Anonymous object (<c>new { id = dto.ProjectId, @minDate = dto.MinDate }</c>), a dictionary or a value array</param>
            <returns>A list.</returns>
            <remarks>
                <para>
                    For more information about the "query" and "parameters" arguments, see <see cref="M:Griffin.Data.Mapper.CommandExtensions.ApplyQuerySql``1(System.Data.IDbCommand,Griffin.Data.Mapper.ICrudEntityMapper{``0},System.String,System.Object[])"/>.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct <c><![CDATA[IEntityMapper<TEntity>]]></c>.</para>
            </remarks>
            <example>
            <code>
            // All these examples are valid:
            <![CDATA[
            var users = unitOfWork.ToList<User>("Age < 10");
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = 37");
            var users = unitOfWork.ToList<User>("FirstName = @name", new { name = user.FirstName });
            var users = unitOfWork.ToList<User>("FirstName = @1 AND Age < @2", 'A%', 35);
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = @age LIMIT 1, 10", new { age = submittedAge });
            var users = unitOfWork.ToList<User>("SELECT * FROM Users WHERE Age = @1 LIMIT 1, 10", user.FirstName);
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingException">
            <summary>
            We did not have a mapping configured for an entity type.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingException"/> class.
            </summary>
            <param name="entityType">Entity that mapping failed for.</param>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.#ctor(System.Type,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingException"/> class.
            </summary>
            <param name="entityType">Entity that mapping failed for.</param>
            <param name="errorMessage">The error message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingException"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown. </param><param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param><exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic). </exception><filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/></PermissionSet>
        </member>
        <member name="P:Griffin.Data.Mapper.MappingException.EntityTypeName">
            <summary>
            Full name of the entity type that we did not have a mapping for.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingForAttribute">
            <summary>
                Will point on the entity that a mapping is for if the <see cref="T:Griffin.Data.Mapper.ICrudEntityMapper"/> interface is used instead of the
                generic one.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingForAttribute.#ctor(System.Type)">
            <summary>
            </summary>
            <param name="entityType"></param>
        </member>
        <member name="P:Griffin.Data.Mapper.MappingForAttribute.EntityType">
            <summary>
                Type of entity that the decorated entity mapper is for.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingNotFoundException">
            <summary>
            We did not have a mapping configured for an entity type.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingNotFoundException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingNotFoundException"/> class.
            </summary>
            <param name="entityType">Entity that we did not find a mapping for.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingNotFoundException.#ctor(System.Type,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingNotFoundException"/> class.
            </summary>
            <param name="entityType">Entity that we did not find a mapping for.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.MappingNotFoundException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Griffin.Data.Mapper.NamespaceDoc">
            <summary>
                Micro data layer making it easier to work with SQL queries.
            </summary>
            <remarks>
                <para></para>
                The command extension uses mapper classes
                to map the database recordset to your entity classes. Hence you need to start by creating mappings as shown below.
                <para>
                    The mappings are retrieve by using the Assem
                </para>
            </remarks>
            <example>
                <para>
                    First you have to define one mapping file per entity that you want to fetch. The following mapping
                    works when the columns are named same as the class properties and they are of the same type:
                </para>
                <code>
            <![CDATA[
            public class UserMapping : ReflectionBasedEntityMapper<User>
            {
            }
            ]]>
            </code>
                <para>
                    You can however customize it to specify a different column name or use an adapter for the column value. Read
                    more in the <see cref="T:Griffin.Data.Mapper.EntityMapper`1"/> documentation.
                </para>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.PropertyMapping`1">
            <summary>
                Used to convert the database column value and assign it to the property/field in the entity.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.#ctor(System.String,System.Action{`0,System.Object},System.Func{`0,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.Mapper.PropertyMapping`1"/> class.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="setter">The setter (optional)</param>
            <param name="getter">The getter (optional)</param>
            <exception cref="T:System.ArgumentNullException">propertyName</exception>
            <example>
              <code>
            var mapping = new PropertyMapping("Id", (instance, value) =&gt; ((User)instance).Id = (string)value);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.Griffin#Data#Mapper#IPropertyMapping#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
                <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.SetColumnValue(System.Object,System.Object)">
            <summary>
                Set property value by specifying a column value (i.e. use the <c>ColumnToPropertyAdapter</c> when assigning the
                value)
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <param name="value">Column value</param>
            <returns>Property value</returns>
            <remarks>
                <para>
                    Will attempt to convert the value if it's not directly assignable to the property type.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.NotForCrud">
            <summary>
                Ignore this property in insert/update statements.
            </summary>
            <exception cref="T:System.InvalidOperationException">Must always write keys.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.NotForQueries">
            <summary>
                Ignore this column when reading from the DB.
            </summary>
            <exception cref="T:System.InvalidOperationException">Must always write keys.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.Map(System.Data.IDataRecord,`0)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
                <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.PropertyType">
            <summary>
                Gets or sets the type of the property.
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.CanWrite">
            <summary>
                Determines if this property can be written to
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.CanRead">
            <summary>
                Determines if this property can be read
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.IsPrimaryKey">
            <summary>
                This property is a primary key
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.IsAutoIncrement">
            <summary>
            PK value is generated by the DB, i.e. do not insert it.
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.PropertyName">
            <summary>
                Name of the property in the entity
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.ColumnName">
            <summary>
                Set if the column name is different from the property name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.ColumnToPropertyAdapter">
            <summary>
                Used to convert the database value to the type used by the property
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.PropertyToColumnAdapter">
            <summary>
                Used to convert the property to the type used by the column.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.ValueHandler">
            <summary>
                Used by the adapters in <see cref="T:Griffin.Data.Mapper.PropertyMapping`1"/>.
            </summary>
            <param name="originalValue">Value from column or property depending on the mapping direction</param>
            <returns>Modified value</returns>
        </member>
        <member name="T:Griffin.Data.NamespaceDoc">
            <summary>
            
            </summary>
        </member>
        <member name="T:Griffin.Data.TransactionAlreadyClosedException">
            <summary>
                A transaction have already been closed.
            </summary>
            <remarks>
                <para>
                    Usually thrown if you have a messy data model where you do not have a full control over how a transaction is
                    created and/or commited.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.TransactionAlreadyClosedException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.TransactionAlreadyClosedException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.TransactionAlreadyClosedException"/> class.
            </summary>
            <param name="info">The data necessary to serialize or deserialize an object.</param>
            <param name="context">Description of the source and destination of the specified serialized stream.</param>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Data.TransactionAlreadyClosedException"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">
                The <paramref name="info" /> parameter is a null reference (Nothing in
                Visual Basic).
            </exception>
            <filterpriority>2</filterpriority>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:Griffin.Data.UnitOfWorkExtensions">
            <summary>
                Expose <c>DbCommand</c> in the UoW.
            </summary>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkExtensions.CreateDbCommand(Griffin.Data.IAdoNetUnitOfWork)">
            <summary>
                Create a Dbcommand
            </summary>
            <param name="unitOfWork"></param>
            <returns></returns>
            <remarks>
                <para>
                    The async methods in ADO.NET is only exposed in the ADO.NET base classes (i.e. <c>DbCommand</c>) and not in the
                    interfaces. We'll therefore
                    have to violate Liskovs Substitution Principle to be able to access them. You should however be fine if you
                    seperate data from business and
                    just do integration tests for your data layer.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkExtensions.ExecuteNonQuery(Griffin.Data.IAdoNetUnitOfWork,System.String,System.Object)">
            <summary>
            Execute a query directly
            </summary>
            <param name="unitOfWork">Unit of work to execute query in</param>
            <param name="sql">sql query</param>
            <param name="parameters">parameters used in the query</param>
            <remarks>
            <para>Do note that the query must be using table column names and not class properties. No mapping is being made.</para>
            <para><c>null</c> is automatically replaced by <c>DBNull.Value</c> for the parameters</para>
            </remarks>
            <example>
            <code>
            public void Execute(IDbConnection connection)
            {
                connection.ExecuteNonQuery("UPDATE Users SET Discount = Discount + 10 WHERE OrganizationId = @orgId", new { orgId = 10});
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.UnitOfWorkFactory">
            <summary>
                Can be used to create unit of work instances in your application.
            </summary>
            <example>
                <para>Assignment:</para>
                <code>
            public IUnitOfWork Create()
            {
                var conString = ConfigurationManager.ConnectionStrings("MyDb").ConnectionString;
                var con = new SqlConnection(conString);
                con.Open();
                return new AdoNetUnitOfWork(con, true);
            }
            
            UnitOfWorkFactory.SetFactoryMethod(() => Create());
            </code>
                <para>Usage:</para>
                <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var repos = new UserRepository(uow);
                repos.Create("Jonas");
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkFactory.Create">
            <summary>
            Create a new unit of work.
            </summary>
            <returns>Created UOW</returns>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkFactory.SetFactoryMethod(System.Func{Griffin.Data.IUnitOfWork})">
            <summary>
                Assign a method which will be used to create an unit of work every time <c>Create()</c> is being called.
            </summary>
            <param name="factoryMethod">Should return a fully functional UoW.</param>
        </member>
        <member name="T:Griffin.External.Inflector.Inflector">
            <summary>
                From: https://github.com/srkirkland/Inflector
                License: MIT
            </summary>
        </member>
        <member name="T:Griffin.Core.External.SimpleJson.JsonArray">
            <summary>
            Represents the json array.
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Core.External.SimpleJson.JsonArray"/> class. 
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonArray.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Core.External.SimpleJson.JsonArray"/> class. 
            </summary>
            <param name="capacity">The capacity of the json array.</param>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonArray.ToString">
            <summary>
            The json representation of the array.
            </summary>
            <returns>The json representation of the array.</returns>
        </member>
        <member name="T:Griffin.Core.External.SimpleJson.JsonObject">
            <summary>
            Represents the json object.
            </summary>
        </member>
        <member name="F:Griffin.Core.External.SimpleJson.JsonObject._members">
            <summary>
            The internal member dictionary.
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Griffin.Core.External.SimpleJson.JsonObject"/>.
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of <see cref="T:Griffin.Core.External.SimpleJson.JsonObject"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the key.</param>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Add(System.String,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
                <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Remove(System.String)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TryGetValue(System.String,System.Object@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Determines whether [contains] [the specified item].
            </summary>
            <param name="item">The item.</param>
            <returns>
            	<c>true</c> if [contains] [the specified item]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <summary>
            Copies to.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Removes the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.ToString">
            <summary>
            Returns a json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>
            Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.
            </summary>
            <param name="binder">Provides information about the conversion operation. The binder.Type property provides the type to which the object must be converted. For example, for the statement (String)sampleObject in C# (CType(sampleObject, Type) in Visual Basic), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Type returns the <see cref="T:System.String"/> type. The binder.Explicit property provides information about the kind of conversion that occurs. It returns true for explicit conversion and false for implicit conversion.</param>
            <param name="result">The result of the type conversion operation.</param>
            <returns>
            Alwasy returns true.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
            <summary>
            Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.
            </summary>
            <param name="binder">Provides information about the deletion.</param>
            <returns>
            Alwasy returns true.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
            <summary>
            Provides the implementation for operations that get a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for indexing operations.
            </summary>
            <param name="binder">Provides information about the operation.</param>
            <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] operation in C# (sampleObject(3) in Visual Basic), where sampleObject is derived from the DynamicObject class, <paramref name="indexes"/> is equal to 3.</param>
            <param name="result">The result of the index operation.</param>
            <returns>
            Alwasy returns true.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>
            Provides the implementation for operations that get member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as getting a value for a property.
            </summary>
            <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the Console.WriteLine(sampleObject.SampleProperty) statement, where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
            <param name="result">The result of the get operation. For example, if the method is called for a property, you can assign the property value to <paramref name="result"/>.</param>
            <returns>
            Alwasy returns true.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
            <summary>
            Provides the implementation for operations that set a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations that access objects by a specified index.
            </summary>
            <param name="binder">Provides information about the operation.</param>
            <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, <paramref name="indexes"/> is equal to 3.</param>
            <param name="value">The value to set to the object that has the specified index. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, <paramref name="value"/> is equal to 10.</param>
            <returns>
            true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject"/> class can override this method to specify dynamic behavior for operations such as setting a value for a property.
            </summary>
            <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member to which the value is being assigned. For example, for the statement sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
            <param name="value">The value to set to the member. For example, for sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject"/> class, the <paramref name="value"/> is "Test".</param>
            <returns>
            true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.JsonObject.GetDynamicMemberNames">
            <summary>
            Returns the enumeration of all dynamic member names.
            </summary>
            <returns>
            A sequence that contains dynamic member names.
            </returns>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:Griffin.Core.External.SimpleJson.JsonObject.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Griffin.Core.External.SimpleJson.SimpleJson">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.SimpleJson.DeserializeObject(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>An IList&lt;object>, a IDictionary&lt;string,object>, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.SimpleJson.TryDeserializeObject(System.String,System.Object@)">
            <summary>
            Try parsing the json string into a value.
            </summary>
            <param name="json">
            A JSON string.
            </param>
            <param name="obj">
            The object.
            </param>
            <returns>
            Returns true if successfull otherwise false.
            </returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.SimpleJson.SerializeObject(System.Object,Griffin.Core.External.SimpleJson.IJsonSerializerStrategy)">
            <summary>
            Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
            </summary>
            <param name="json">A IDictionary&lt;string,object> / IList&lt;object></param>
            <param name="jsonSerializerStrategy">Serializer strategy to use</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="M:Griffin.Core.External.SimpleJson.SimpleJson.IsNumeric(System.Object)">
            <summary>
            Determines if a given object is numeric in any way
            (can be integer, double, null, etc).
            </summary>
        </member>
        <member name="T:Griffin.GuidFactory">
            <summary>
                Produce GUIDs with are used internally in this library
            </summary>
            <remarks>
                <para>
                    Can be used to use specialized guids as COMBs to increase performance of data source lookups.
                </para>
                <para>The default implementation uses <c>Guid.NewGuid()</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.GuidFactory.Assign(Griffin.GuidFactory)">
            <summary>
                Assign a new factory
            </summary>
            <param name="factory">Factory to use</param>
        </member>
        <member name="M:Griffin.GuidFactory.Create">
            <summary>
                Generate a new GUID
            </summary>
            <returns>Guid of some sort.</returns>
        </member>
        <member name="M:Griffin.GuidFactory.CreateInternal">
            <summary>
                Generate a new GUID using the assign implementation
            </summary>
            <returns>Guid of some sort</returns>
        </member>
        <member name="T:Griffin.InstanceFactory">
            <summary>
            Delegate returned by <see cref="M:Griffin.ConstructorExtensions.CreateFactory(System.Reflection.ConstructorInfo)"/>.
            </summary>
            <param name="args">Constructor arguments</param>
            <returns>Created object</returns>
        </member>
        <member name="T:Griffin.IO.DirectoryUtils">
            <summary>
            Missing .NET features for Directory management.
            </summary>
        </member>
        <member name="M:Griffin.IO.DirectoryUtils.Copy(System.String,System.String,System.Boolean)">
            <summary>
            Copies files from one folder to another. Source security settings are included.
            </summary>
            <param name="source">The source.</param>
            <param name="destination">The destination.</param>
            <param name="copySubDirs">if set to <c>true</c>, sub directories are also copied.</param>
            <exception cref="T:System.ArgumentNullException">
            source
            or
            destination
            </exception>
        </member>
        <member name="M:Griffin.IO.DirectoryUtils.Copy(System.String,System.String,System.Boolean,System.Security.AccessControl.DirectorySecurity)">
            <summary>
            Copies files from one directory to another.
            </summary>
            <param name="source">The source.</param>
            <param name="destination">The destination.</param>
            <param name="copySubDirs">if set to <c>true</c>, copy all contents from the sub directories too.</param>
            <param name="security">The security.</param>
            <exception cref="T:System.ArgumentNullException">
            source
            or
            destination
            or
            security
            </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Source directory does not exist or could not be found: 
                                + source</exception>
        </member>
        <member name="T:Griffin.IO.NamespaceDoc">
            <summary>
            An old implementation of a persistant queue. A faster and more robust one will be added.
            </summary>
        </member>
        <member name="T:Griffin.IO.OneFilePerItemQueue`1">
            <summary>
                Stores every queued item in a separate file.
            </summary>
            <remarks>
                <para>
                    Creates a new directory under the <see cref="P:Griffin.IO.OneFilePerItemQueue`1.DataDirectory"/> which is named as <see cref="P:Griffin.IO.OneFilePerItemQueue`1.QueueName"/>. That
                    directory will
                    be used to store all files using a number counter and <c>.data</c> as file extension.
                </para>
                <para>
                    This library will create the data directory and the queue directory automatically if they do not exist. By
                    default EVERYONE will
                    receive read/write permissions to that directory. If you want to reconfigure that you have to use the
                    <see cref="P:Griffin.IO.OneFilePerItemQueue`1.DataDirectorySecurity"/> property.
                </para>
            </remarks>
            <typeparam name="T">Type of queued item</typeparam>
        </member>
        <member name="T:Griffin.IQueue`1">
            <summary>
            A queue definition
            </summary>
            <typeparam name="T">Type of entity to store in the queue</typeparam>
        </member>
        <member name="M:Griffin.IQueue`1.DequeueAsync">
            <summary>
            Dequeue an item from our queue.
            </summary>
            <returns>Dequeued item; <c>default(T)</c> if there are no more items in the queue.</returns>
        </member>
        <member name="M:Griffin.IQueue`1.EnqueueAsync(`0)">
            <summary>
            Enqueue item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.IO.OneFilePerItemQueue`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.OneFilePerItemQueue`1"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
        </member>
        <member name="M:Griffin.IO.OneFilePerItemQueue`1.DequeueAsync">
            <summary>
                Dequeue an item from our queue.
            </summary>
            <returns>Dequeued item; <c>default(T)</c> if there are no more items in the queue.</returns>
        </member>
        <member name="M:Griffin.IO.OneFilePerItemQueue`1.EnqueueAsync(`0)">
            <summary>
                Enqueue item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.IO.OneFilePerItemQueue`1.Serializer">
            <summary>
                Used to serialize items.
            </summary>
            <value>
                Default is <see cref="T:Griffin.IO.Serializers.BinaryFormatterSerializer"/>.
            </value>
        </member>
        <member name="P:Griffin.IO.OneFilePerItemQueue`1.DataDirectory">
            <summary>
                Directory to store items in.
            </summary>
            <remarks>
                This name is combined with the queue name. i.e. if the data directory is "C:\Queues" and the queueName is
                "Commands" the directory to use
                will be "C:\Queues\Commands".
            </remarks>
            <value>
                Default is
                <c>Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "GriffinFramework")</c>
            </value>
        </member>
        <member name="P:Griffin.IO.OneFilePerItemQueue`1.DataDirectorySecurity">
            <summary>
                Used when creating directories automatically.
            </summary>
        </member>
        <member name="P:Griffin.IO.OneFilePerItemQueue`1.QueueName">
            <summary>
                Name of the current queue
            </summary>
        </member>
        <member name="T:Griffin.IO.PersistentCircularIndex">
            <summary>
                A circular index.
            </summary>
            <remarks>
                <para>
                    Stores an index file on disk which is intended for a queue with a known size. The implementation works like a
                    circular queue where there are two pointers defined
                    in the file, one for the next read position and one for the next write position. In that way we can minimize
                    the number of reads required to read/write from the
                    file.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.IO.PersistentCircularIndex.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.PersistentCircularIndex"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="maxDataSize">Maximum size of the data.</param>
            <param name="maxQueueSize">Maximum size of the queue.</param>
        </member>
        <member name="M:Griffin.IO.PersistentCircularIndex.Enqueue(System.String)">
            <summary>
            Enqueue a new string
            </summary>
            <param name="data">The data.</param>
            <exception cref="T:System.ArgumentNullException">data</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">data;Record size is max  + recordSize +  bytes.</exception>
            <exception cref="T:Griffin.QueueFullException"></exception>
        </member>
        <member name="T:Griffin.IO.PersistentQueue`1">
            <summary>
            Used to store items on disk
            </summary>
            <typeparam name="T">Type of item to store, may be a base type.</typeparam>
        </member>
        <member name="M:Griffin.IO.PersistentQueue`1.#ctor(Griffin.IO.PersistentQueueConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.PersistentQueue`1"/> class.
            </summary>
            <exception cref="T:System.ArgumentNullException">dataDirectory</exception>
        </member>
        <member name="M:Griffin.IO.PersistentQueue`1.DequeueAsync">
            <summary>
            Dequeue an item
            </summary>
            <returns>Task that will complete once an item have been successfully read from disk</returns>
        </member>
        <member name="M:Griffin.IO.PersistentQueue`1.EnqueueAsync(`0)">
            <summary>
            enqueue an item
            </summary>
            <param name="item">Item to enqueue</param>
            <returns>Task that completes once the item have been successfully written to disk.</returns>
        </member>
        <member name="P:Griffin.IO.PersistentQueue`1.Encoding">
            <summary>
            Encoding used during serialization
            </summary>
        </member>
        <member name="T:Griffin.IO.Serializers.BinaryFormatterSerializer">
            <summary>
            Wraps around <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
            </summary>
        </member>
        <member name="T:Griffin.ISerializer">
            <summary>
                Serialize/deserialize an object
            </summary>
        </member>
        <member name="M:Griffin.ISerializer.Serialize(System.Object,System.IO.Stream)">
            <summary>
                Serialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to serialize object</exception>
        </member>
        <member name="M:Griffin.ISerializer.Serialize(System.Object,System.IO.Stream,System.Type)">
            <summary>
                Serialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <param name="baseType">
                If specified, we should be able to differentiate sub classes, i.e. include type information if
                <c>source</c> is of another type than this one.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to serialize object</exception>
        </member>
        <member name="M:Griffin.ISerializer.Deserialize(System.IO.Stream,System.Type)">
            <summary>
                Deserialize a stream
            </summary>
            <param name="source">Stream to read from</param>
            <param name="targetType">Type to deserialize. Should be the base type if inheritance is used.</param>
            <returns>Serialized object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to deserialize object</exception>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Serialize(System.Object,System.IO.Stream)">
            <summary>
            Serialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Serialize(System.Object,System.IO.Stream,System.Type)">
            <summary>
            Serialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <param name="baseType">If specified, we should be able to differentiate sub classes, i.e. include type information if
            <c>source</c> is of another type than this one.</param>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Deserialize(System.IO.Stream,System.Type)">
            <summary>
            Deserialize a stream
            </summary>
            <param name="source">Stream to read from</param>
            <param name="targetType">Type to deserialize. Should be the base type if inheritance is used.</param>
            <returns>
            Serialized object
            </returns>
        </member>
        <member name="T:Griffin.IO.PersistentQueueConfiguration">
            <summary>
            Configuration options for <see cref="T:Griffin.IO.PersistentQueue`1"/>.
            </summary>
        </member>
        <member name="M:Griffin.IO.PersistentQueueConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.PersistentQueueConfiguration"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.MaxCount">
            <summary>
            Max amount of items in the queue
            </summary>
            <remarks>
            <para>
            The implementation is using a circular index file where all records are pre-created. You therefore have to specify the maximum amount of items that can be in the queue. The index
            file is approximely 32 bytes * MaxCount bytes large. i.e. 1000 records means a 32 000 bytes large index file.
            </para>
            </remarks>
            <value>
            Default is 100.
            </value>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.QueueName">
            <summary>
            Name of the queue
            </summary>
            <remarks>
            <para>
            A sub directory will be created with this name and the index file will also be named as the specified name.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.DataDirectory">
            <summary>
            
            </summary>
            <example>
            <para>You can get a windows folder by doing like this:</para>
            <code>
             var path = Environment.GetFolderPath(rootFolder);
             path = Path.Combine(path, @"MyAppName\Queues");
            
             config.DataDirectory = path;
            </code>
            </example>
            <value>
            Default is <c>Path.GetTempPath()</c>
            </value>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.Serializer">
            <summary>
            Kind of serializer to use.
            </summary>
            <remarks>
            <para>
            Install the nuget package <c>Griffin.Framework.Json</c> if you would like to use JSON.NET.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.ILogEntryFilter">
            <summary>
                Decides which log entries each logger should accept.
            </summary>
            <remarks>
                <para>
                    The logging library can use to types of filters. Logger filters which decide which log each type should write
                    to. The other kind of filters are implemented by this class: Once a logger receives a log entry, these filters
                    are used to determine which log entry can be logged.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.ILogEntryFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
                Check if the logger may write this entry.
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns><c>true</c> if the entry can be written; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.ILogger">
            <summary>
            Logging interface
            </summary>
            <remarks>You typically just want to log the warnings and the errors from the framework since your logs
            will probably be filled very quickly otherwise.</remarks>
        </member>
        <member name="M:Griffin.Logging.ILogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Debug(System.String,System.Object[])">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write a previously created log instance.
            </summary>
            <param name="entry">Entry to write to the logfile.</param>
        </member>
        <member name="T:Griffin.Logging.ILoggerFilter">
            <summary>
                Used to determine which loggers a specific type can log to.
            </summary>
        </member>
        <member name="M:Griffin.Logging.ILoggerFilter.IsSatisfiedBy(System.Type)">
            <summary>
                Checks if the specified logger may log to a certain logger.
            </summary>
            <param name="typeThatWantToLog">Type that want's to write to a log.</param>
            <returns><c>true</c> if the logging type is acceptable by this filter; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.ILogProvider">
            <summary>
            Factory which produces loggers when requested.
            </summary>
        </member>
        <member name="M:Griffin.Logging.ILogProvider.GetLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="typeThatWantToLog">Type which want's to write to the log file</param>
            <returns>Logger to use (must not be <c>null</c>).</returns>
        </member>
        <member name="T:Griffin.Logging.LogEntry">
            <summary>
            Entry to write
            </summary>
        </member>
        <member name="M:Griffin.Logging.LogEntry.#ctor(Griffin.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.LogEntry"/> class.
            </summary>
            <param name="logLevel">The log level, see the enum for a detail description of each level..</param>
            <param name="message">Message written by the dev.</param>
            <param name="exception">exception (if any).</param>
            <exception cref="T:System.ArgumentNullException">message</exception>
        </member>
        <member name="P:Griffin.Logging.LogEntry.WrittenAt">
            <summary>
            When the log entry was written
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.LogLevel">
            <summary>
            log level, see the enum for a detail description of each level
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.Message">
            <summary>
            Message written by the dev
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.Exception">
            <summary>
            Exception if any.
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.BaseLogger">
            <summary>
            Base class for loggers.
            </summary>
            <remarks>All you have to do is to override the <see cref="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogEntry)"/> method.</remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.BaseLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type of the class which uses this log. The type is used to write in the log file where the lines come from.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Debug(System.String,System.Object[])">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Checks our log filter and then calls the abstract method
            </summary>
            <param name="logLevel">Log level.</param>
            <param name="msg">Message to write.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.BuildExceptionDetails(System.Exception,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats exception details (including all inner exceptions)
            </summary>
            <param name="exception">Thrown exception.</param>
            <param name="spaces">Number of spaces to prefix each line with.</param>
            <param name="result">The created information will be appended to this string builder.</param>
            <remarks>Increases the number of spaces for each inner exception so it's easy to see all information</remarks>
        </member>
        <member name="P:Griffin.Logging.Loggers.BaseLogger.LoggedType">
            <summary>
            Gets the type for the class which logs using this class
            </summary>
        </member>
        <member name="P:Griffin.Logging.Loggers.BaseLogger.LogFilter">
            <summary>
            Used to determine if a log entry can be written to the log or not.
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.CompositeLogger">
            <summary>
                Can be used to write to several logs in one run.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.#ctor(System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.CompositeLogger"/> class.
            </summary>
            <param name="typeThatLogs">
                Type of the class which uses this log. The type is used to write in the log file where the
                lines come from.
            </param>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.Add(Griffin.Logging.ILogger)">
            <summary>
                Add another logger that each entry should be written to
            </summary>
            <param name="logger">Logger to write to</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
                Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
            <exception cref="T:System.ArgumentNullException">entry</exception>
        </member>
        <member name="T:Griffin.Logging.Loggers.ConsoleLogger">
            <summary>
            Log everything to the console
            </summary>
            <remarks>Prints one stack frame using colored output.</remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.ConsoleLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type being logged.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.GetStackFrame">
            <summary>
            Used to get the correct frame when <see cref="P:Griffin.Logging.Loggers.ConsoleLogger.UseStackFrame"/> is set to true.
            </summary>
            <returns></returns>
            <remarks>
            <para>Will traverse all frames in the stack the first time this method is called. Will only get the correct frame all other times.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.GetColor(Griffin.Logging.LogLevel)">
            <summary>
            Get a color for a specific log level
            </summary>
            <param name="logLevel">Level to get color for</param>
            <returns>Level color</returns>
        </member>
        <member name="P:Griffin.Logging.Loggers.ConsoleLogger.UseStackFrame">
            <summary>
            Specifies if we should use stack frame to identify the caller (instead of <c>loggedType</c>)
            </summary>
            <remarks>
            <para>Do note that there is a performance hit by using this class.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.ExceptionsOnly">
            <summary>
            Only allow entries that got exceptions
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.ExceptionsOnly.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
            Check if the entry have an exception
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
              <c>true</c> if the entry has an exception; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.LogLevelFilter">
            <summary>
                Filters on log level
            </summary>
            <example>
                <code>
            var logger = new ConsoleLogger();
            logger.LogFilter = new LogLevelFilter { MinLevel = LogLevel.Info };
            
            var provider = new LogProvider();
            provider.Add(logger);
            
            LogManager.Provider = provider;
            </code>
            </example>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.LogLevelFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.Filters.LogLevelFilter"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.LogLevelFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
                Check if the logger may write this entry.
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
                <c>true</c> if the entry can be written; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:Griffin.Logging.Loggers.Filters.LogLevelFilter.MinLevel">
            <summary>
                Minimum level (inclusive)
            </summary>
            <value>
                Default is <see cref="F:Griffin.Logging.LogLevel.Debug"/>.
            </value>
        </member>
        <member name="P:Griffin.Logging.Loggers.Filters.LogLevelFilter.MaxLevel">
            <summary>
                Maximum level (inclusive)
            </summary>
            <value>
                Default is <see cref="F:Griffin.Logging.LogLevel.Error"/>.
            </value>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.NamespaceDoc">
            <summary>
                These filters are used to control which log entries are allowed in which logger.
            </summary>
            <remarks>
                <para>
                    You can for instance make sure that only entries with an exception is written to a file logger named
                    "exeptions.log";
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.NoFilter">
            <summary>
                Can be used to disable filtering
            </summary>
        </member>
        <member name="F:Griffin.Logging.Loggers.Filters.NoFilter.Instance">
            <summary>
                Instance to use
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.NoFilter.#ctor">
            <summary>
                Prevents a default instance of the <see cref="T:Griffin.Logging.Loggers.Filters.NoFilter"/> class from being created.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.NoFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
            Will always return true;
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
              <c>true</c>, always.
            </returns>
        </member>
        <member name="T:Griffin.Logging.Loggers.NamespaceDoc">
            <summary>
                Loggers are the classes which writes log entries to the different destinations.
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.NullLogger">
            <summary>
            Throws away all logs
            </summary>
        </member>
        <member name="F:Griffin.Logging.Loggers.NullLogger.Instance">
            <summary>
            Singleton
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find weird errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Debug(System.String,System.Object[])">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write a previously created log instance.
            </summary>
            <param name="entry">Entry to write to the logfile.</param>
        </member>
        <member name="T:Griffin.Logging.Loggers.SystemDebugLogger">
            <summary>
            Logs to the debug window in Visual Studio
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.SystemDebugLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.SystemDebugLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type of the class which uses this log. The type is used to write in the log file where the lines come from.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.SystemDebugLogger.GetStackFrame">
            <summary>
            Used to get the correct frame when <see cref="P:Griffin.Logging.Loggers.SystemDebugLogger.UseStackFrame"/> is set to true.
            </summary>
            <returns></returns>
            <remarks>
            <para>Will traverse all frames in the stack the first time this method is called. Will only get the correct frame all other times.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.SystemDebugLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
        </member>
        <member name="P:Griffin.Logging.Loggers.SystemDebugLogger.UseStackFrame">
            <summary>
            Specifies if we should use stack frame to identify the caller (instead of <c>loggedType</c>)
            </summary>
            <remarks>
            <para>Do note that there is a performance hit by using this class.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.LogLevel">
            <summary>
            Log levels
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Trace">
            <summary>
            Very detailed logs used during diagnostics
            </summary>
            <remarks>
            Should not be used other when trying to find hard-to-locate errors. You can disable trace output by using a <see cref="T:Griffin.Logging.ILogEntryFilter"/>.
            </remarks>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Debug">
            <summary>
            Diagnostics (like executing a SQL query)
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Info">
            <summary>
            Events and similar (for instance that a user have logged in)
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Warning">
            <summary>
            Something failed, but processing can continue. 
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Error">
            <summary>
            Something failed, expected execution path can not succeed.
            </summary>
        </member>
        <member name="T:Griffin.Logging.LogManager">
            <summary>
                Logging facade
            </summary>
            <remarks>
                <para>
                    Implement a <see cref="T:Griffin.Logging.ILogProvider"/> and assign it using the property <see cref="P:Griffin.Logging.LogManager.Provider"/>. You can also
                    use the default one named <see cref="T:Griffin.Logging.Providers.LogProvider"/>.
                </para>
                <para>The default behavior is to not log at all.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.LogManager.GetLogger``1">
            <summary>
                Get a logger
            </summary>
            <typeparam name="T">Type requesting a logger</typeparam>
            <returns>A logger</returns>
        </member>
        <member name="M:Griffin.Logging.LogManager.GetLogger(System.Type)">
            <summary>
                Get a logger
            </summary>
            <param name="typeThatWantsToLog">Type that will log messages</param>
            <returns>A logger</returns>
        </member>
        <member name="P:Griffin.Logging.LogManager.Provider">
            <summary>
                Get the current adapter
            </summary>
        </member>
        <member name="T:Griffin.Logging.NamespaceDoc">
            <summary>
                A simple logging layer which can be used to log entries to whatever you want.
            </summary>
            <remarks>
                <para>
                    To get started you should create a <see cref="T:Griffin.Logging.Providers.LogProvider"/> and assign loggers to it. Finally assign it to
                    the <see cref="P:Griffin.Logging.LogManager.Provider"/> to finish initialization.
                </para>
                <para>Now you can use the <c>GetLogger()</c> methods in your classes to access loggers.</para>
            </remarks>
            <example>
                <para>To setup the logging library:</para>
                <code>
            <![CDATA[
            var consoleLogger = new ConsoleLogger() { Filter = new OnlyExceptions() };
            var systemDebugLogger = new SystemDebugLogger() { Filter = LogLevelFilter { MinLevel = LogLevel.Info } };
            var logProvider = new LogProvider();
            logProvider.Add(consoleLogger);
            logProvider.Add(systemDebugLogger, new NamespaceFilter("MyApp.Core"));
            
            LogManager.Provider = logProvider;
            ]]>
            </code>
                <para>And to use it:</para>
                <code>
            <![CDATA[
            public class YourClass
            {
                ILogger _logger = LogManager.GetLogger<YourClass>();
            
                public void SomeMethod()
                {
                    _logger.Info("Hello {0}", "world");
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Logging.Providers.LogProvider">
            <summary>
                Default implementation of a log factory.
            </summary>
            <remarks>
                <para>
                    The first matching logger is the one that will be returned when a logger is requested. So add the most
                    restrictive logger first (if the first logger is not using any filter it will be returned every time).
                </para>
            </remarks>
            <example>
                <code>
            var factory = new LogFactory();
            factory.Add(new NamespaceFilter("Griffin", true), type => new ConsoleLogger(type));
            LogManager.Factory = factory;
            </code>
            </example>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.GetLogger(System.Type)">
            <summary>
                Creates the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>Logger to use (or <see cref="F:Griffin.Logging.Loggers.NullLogger.Instance"/> if none is found)</returns>
            <exception cref="T:System.ArgumentNullException">type</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger)">
            <summary>
                Add a logger
            </summary>
            <param name="logger">Add a logger (will be used for all classes that want to log)</param>
            <remarks>
                <para>
                    If you want to limit which classes a logger should be able to handle you need to use the other overload:
                    <see cref="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger,Griffin.Logging.ILoggerFilter)"/>
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger,Griffin.Logging.ILoggerFilter)">
            <summary>
                Add a logger and limit which classes that can log to it.
            </summary>
            <param name="logger">Logger to use.</param>
            <param name="filter">Filter that logging types must pass.</param>
        </member>
        <member name="T:Griffin.Logging.Providers.NamespaceDoc">
            <summary>
            Classes which are used to deliver logs to the facade.
            </summary>
            <example>
            <code>
            // Create loggers
            var consoleLogger = new ConsoleLogger() { Filter = new OnlyExceptions() };
            var systemDebugLogger = new SystemDebugLogger() { Filter = LogLevelFilter { MinLevel = LogLevel.Info } };
            
            // Create the provider
            var logProvider = new LogProvider();
            logProvider.Add(consoleLogger);
            
            // can filter on namespaces.
            logProvider.Add(systemDebugLogger, new NamespaceFilter("MyApp.Core"));
            </code>
            </example>
        </member>
        <member name="T:Griffin.Logging.Providers.NamespaceFilter">
            <summary>
                Allows user to filter on certain namespaces.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Providers.NamespaceFilter"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.#ctor(System.String,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Providers.NamespaceFilter"/> class.
            </summary>
            <param name="allowedIncludingChildNamespaces">A namespace to allow, <c>null</c> = do not add.</param>
            <param name="revokedIncludingChildNamespaces">A namespace to revoke, <c>null</c> = do not add.</param>
            <remarks>
                Constructor can be used to get less bootstrapping code.
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.IsSatisfiedBy(System.Type)">
            <summary>
                Checks if the specified logger may log to a certain logger.
            </summary>
            <param name="typeThatWantToLog">Type that want's to write to a log.</param>
            <returns>
                <c>true</c> if the logging type is acceptable by this filter; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">typeThatWantToLog</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.Allow(System.String,System.Boolean)">
            <summary>
                Allows the specified the namespace.
            </summary>
            <param name="theNamespace">The namespace to allow.</param>
            <param name="allowChildNamespaces">if set to <c>true</c> all child namespaces is also allowed.</param>
            <exception cref="T:System.ArgumentNullException">theNamespace</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.Revoke(System.String,System.Boolean)">
            <summary>
                Revokes the specified the namespace.
            </summary>
            <param name="theNamespace">The namespace.</param>
            <param name="includeChildNamespaces">if set to <c>true</c> all child namespaces is also revoked.</param>
            <exception cref="T:System.ArgumentNullException">theNamespace</exception>
        </member>
        <member name="T:Griffin.Logging.Providers.NoFilter">
            <summary>
            Disable filtering.
            </summary>
        </member>
        <member name="F:Griffin.Logging.Providers.NoFilter.Instance">
            <summary>
                Instance to use
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NoFilter.#ctor">
            <summary>
                Prevents a default instance of the <see cref="T:Griffin.Logging.Providers.NoFilter"/> class from being created.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NoFilter.IsSatisfiedBy(System.Type)">
            <summary>
            Will always return true
            </summary>
            <param name="typeThatWantToLog">Type that wants to get a logger to be able to log entries that have been written by the dev.</param>
            <returns>Always <c>true</c>. <c>true</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.Providers.NullLogProvider">
            <summary>
            Just returns <see cref="F:Griffin.Logging.Loggers.NullLogger.Instance"/> for every request.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NullLogProvider.GetLogger(System.Type)">
            <summary>
            Gets the logger.
            </summary>
            <param name="type">The type that wants to log.</param>
            <returns></returns>
        </member>
        <member name="T:Griffin.MemoryQueue`1">
            <summary>
                Wraps <c><![CDATA[ConcurrentQueue<T>]]></c>
            </summary>
            <typeparam name="T">Type of item to store.</typeparam>
        </member>
        <member name="M:Griffin.MemoryQueue`1.DequeueAsync">
            <summary>
                Dequeue an item from our queue.
            </summary>
            <returns>Dequeued item; <c>default(T)</c> if there are no more items in the queue.</returns>
        </member>
        <member name="M:Griffin.MemoryQueue`1.EnqueueAsync(`0)">
            <summary>
                Enqueue item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.MethodInfoExtensions">
            <summary>
                Extension methods for <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="M:Griffin.MethodInfoExtensions.ToFastDelegate(System.Reflection.MethodInfo)">
            <summary>
                Create a fast delegete from the method info which also takes care of casting.
            </summary>
            <param name="method">Method to convert</param>
            <returns>Delegate to invoke</returns>
        </member>
        <member name="T:Griffin.MethodInfoExtensions.LateBoundMethod">
            <summary>
                Delegate for <see cref="M:Griffin.MethodInfoExtensions.ToFastDelegate(System.Reflection.MethodInfo)"/>.
            </summary>
            <param name="instance">instance to invoke the method on</param>
            <param name="arguments">method arguments</param>
            <returns>Result (if any)</returns>
        </member>
        <member name="T:Griffin.NamespaceDoc">
            <summary>
            This is the API documentation for Griffin framework. To see examples and usage documentation go to http://griffinframework.net/doc/.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.AuthenticationDeniedException">
            <summary>
            Failed to authenticate
            </summary>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationDeniedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationDeniedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationDeniedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationDeniedException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationDeniedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationDeniedException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationDeniedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <PermissionSet>
              <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
              <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
              </PermissionSet>
        </member>
        <member name="T:Griffin.Net.Authentication.AuthenticationRequiredException">
            <summary>
                Thrown when the client needs to authenticate
            </summary>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationRequiredException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationRequiredException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationRequiredException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationRequiredException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationRequiredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.AuthenticationRequiredException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:Griffin.Net.Authentication.AuthenticationRequiredException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator">
            <summary>
                Authenticate using the built in mechanism in Griffin.Framework. requires that the lite server is using the
                <c>HashAuthenticationModule</c>.
            </summary>
            <remarks>
                <para>
                    To make this work you need to have stored passwords in your database by hashing them with a salt. The hash must
                    have been
                    created using <c>Rfc2898DeriveBytes</c> with 1000 iterations upon the string "password:hash". You you are using
                    another
                    way of storing passwords in your DB you need to configure the authentication process using
                    <see cref="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.ConfigureAuthentication(Griffin.Security.IPasswordHasher,Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory)"/>.
                </para>
                <para>
                    If you are using something else than our own hashing algortihm (<see cref="T:Griffin.Security.PasswordHasherRfc2898"/>) for
                    storing passwords you need to set your own
                    algortihm using <see cref="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.ConfigureAuthentication(Griffin.Security.IPasswordHasher,Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory)"/>.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Authentication.IClientAuthenticator">
            <summary>
                Used to authenticate in the client
            </summary>
        </member>
        <member name="M:Griffin.Net.Authentication.IClientAuthenticator.Process(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
                authenticate using serialized messages
            </summary>
            <param name="channel">channel to authenticate</param>
            <param name="message">Received message, will be <see cref="T:Griffin.Net.Authentication.AuthenticationRequiredException"/> first time and then responses to your authentication messages</param>
            <returns><c>true</c> if authentication process completed.</returns>
        </member>
        <member name="M:Griffin.Net.Authentication.IClientAuthenticator.Process(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Channels.ISocketBuffer,System.Boolean@)">
            <summary>
                Process raw bytes.
            </summary>
            <param name="channel">Channel that the bytes came from</param>
            <param name="buffer">Buffer to process</param>
            <param name="completed">Authentication process have completed, we either failed or succeeded</param>
            <returns>Number of bytes processed from the buffer.</returns>
        </member>
        <member name="P:Griffin.Net.Authentication.IClientAuthenticator.RequiresRawData">
            <summary>
                Determins if this client requires raw byte data to be able to authenticate
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.IClientAuthenticator.AuthenticationFailed">
            <summary>
                If we've failed to authenticate (no need to try again unless credentials are changed)
            </summary>
        </member>
        <member name="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.#ctor(System.Net.NetworkCredential)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator"/> class.
            </summary>
            <param name="credential">The credential to login with.</param>
            <exception cref="T:System.ArgumentNullException">credential</exception>
            <remarks>
                <para>See class documentation for more information about how this client works</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.Process(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
            authenticate using serialized messages
            </summary>
            <param name="channel">channel to authenticate</param>
            <param name="message">Received message, will be <see cref="T:Griffin.Net.Authentication.AuthenticationRequiredException"/> first time and then responses to your authentication messages</param>
            <returns>
              <c>true</c> if authentication process completed.
            </returns>
        </member>
        <member name="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.Process(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Channels.ISocketBuffer,System.Boolean@)">
            <summary>
            </summary>
            <param name="channel"></param>
            <param name="buffer"></param>
            <param name="completed"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.ConfigureAuthentication(Griffin.Security.IPasswordHasher,Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory)">
            <summary>
                Used to configure how passwords are being hashed and which messages should be used when transfering authentication
                information
                over the network.
            </summary>
            <param name="hasher">Password hasher, the dault one is <see cref="T:Griffin.Security.PasswordHasherRfc2898"/>.</param>
            <param name="messageFactory">Message factory, the default on is <see cref="T:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory"/>.</param>
        </member>
        <member name="P:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.Credential">
            <summary>
                Use this method if you want to use the built in authentication library.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.RequiresRawData">
            <summary>
                Will always return <c>false</c> as this implementation only works with serialized messages.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.HashAuthenticator.HashClientAuthenticator.AuthenticationFailed">
            <summary>
                Wether we have failed to authenticate
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.IUserAccount">
            <summary>
                Implement this class with your own user account class.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.IUserAccount.UserName">
            <summary>
                User identity (as entered by the user during the login process)
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.IUserAccount.HashedPassword">
            <summary>
                Password hashed in the same was as used by <see cref="T:Griffin.Security.IPasswordHasher"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.IUserAccount.PasswordSalt">
            <summary>
                Salt generated when the password was hashed.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.IUserAccount.IsLocked">
            <summary>
                Account is locked (the user may not login event if the password is correct)
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.Authenticate">
            <summary>
            Step three, Used by the client to prove that it knows the password (i.e. is who it states that it is)
            </summary>
            <remarks>
            <para>Uses the data contract attributes</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.IAuthenticate">
            <summary>
                Step three, Used by the client to prove that it knows the password (i.e. is who it states that it is)
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticate.AuthenticationToken">
            <summary>
                On the client, salt the password with the account salt and hash it (keep this as " client shared secret"),
                then salt the result with the session salt and hash it again. Transmit this as an authentication token (not secret)
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticate.ClientSalt">
            <summary>
                Salt that the client want the server to use to prove it's identity
            </summary>
            <remarks>
                <para>
                    The server must hash the password hash with this hash to prove that it's the real server.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.Authenticate.AuthenticationToken">
            <summary>
            On the client, salt the password with the account salt and hash it (keep this as " client shared secret"),
            then salt the result with the session salt and hash it again. Transmit this as an authentication token (not secret)
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.Authenticate.ClientSalt">
            <summary>
                Salt that the client want the server to use to prove it's identity
            </summary>
            <remarks>
                <para>
                    The server must hash the password hash with this hash to prove that it's the real server.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.AuthenticateReply">
            <summary>
            Default implementation which is Serializable and tagged with data contract attributes.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.IAuthenticateReply">
            <summary>
                Finaly step of the authentication process.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticateReply.State">
            <summary>
                Returns wether the user may login or not
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticateReply.AuthenticationToken">
            <summary>
                Token created by the server to prove it's identity
            </summary>
            <remarks>
                <para>
                    It's generated with the help of the client salt and the password hash that is stored for the user.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.AuthenticateReply.State">
            <summary>
            Returns wether the user may login or not
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.AuthenticateReply.AuthenticationToken">
            <summary>
                Token created by the server to prove it's identity
            </summary>
            <remarks>
                <para>
                    It's generated with the help of the client salt and the password hash that is stored for the user.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.AuthenticateReplyState">
            <summary>
            State for <see cref="T:Griffin.Net.Authentication.Messages.IAuthenticateReply"/>
            </summary>
        </member>
        <member name="F:Griffin.Net.Authentication.Messages.AuthenticateReplyState.Success">
            <summary>
            Successful login
            </summary>
        </member>
        <member name="F:Griffin.Net.Authentication.Messages.AuthenticateReplyState.IncorrectLogin">
            <summary>
            Password failed.
            </summary>
        </member>
        <member name="F:Griffin.Net.Authentication.Messages.AuthenticateReplyState.Locked">
            <summary>
            Account have been locked (to many attempts or disabled account)
            </summary>
        </member>
        <member name="F:Griffin.Net.Authentication.Messages.AuthenticateReplyState.ServerError">
            <summary>
            Failed to login due to an error in the server application.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory">
            <summary>
                Default implementation which creates the default messages defined in the [Messages](Messages) folder.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory">
            <summary>
                Used to create the authentication messages which are sent between the client/server.
            </summary>
            <remarks>
                <para>
                    Some serializer require that messages have been tagged with attributes or are constructed in a certain way.
                    This contract allows
                    you to create messages that works with your currently selected message serializer.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory.CreateHandshake(System.String)">
            <summary>
                Create the first message (sent from the client to the server once connected)
            </summary>
            <param name="userName">Name of the user.</param>
            <returns>
                message that can be serialized
            </returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory.CreateServerPreAuthentication(Griffin.Net.Authentication.IUserAccount)">
            <summary>
                Create the message that are sent from the server to the client with the salts that should be used during the
                authentication.
            </summary>
            <param name="user">User that want to be authenticated</param>
            <returns>message that can be serialized</returns>
            <remarks>
            <para>You are responsible of generating the session salt. You can for instance do that by using <see cref="M:Griffin.Security.PasswordHasherRfc2898.CreateSalt"/>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory.CreateAuthentication(System.String)">
            <summary>
                The last authentication step. Contains the hashed authentication string
            </summary>
            <returns>message that can be serialized</returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.IAuthenticationMessageFactory.CreateAuthenticationResult(Griffin.Net.Authentication.Messages.AuthenticateReplyState,System.String)">
            <summary>
                Sent by server to indicate how the authentication went
            </summary>
            <param name="state">How it went</param>
            <param name="authenticationToken">Token created by the server using <see cref="P:Griffin.Net.Authentication.Messages.IAuthenticate.ClientSalt"/> to prove the server identity. <c>null</c> if authentication failed.</param>
            <returns>message that can be serialized</returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.#ctor(Griffin.Security.IPasswordHasher)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory"/> class.
            </summary>
            <param name="hasher">The hasher.</param>
            <exception cref="T:System.ArgumentNullException">hasher</exception>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.CreateHandshake(System.String)">
            <summary>
                Create the first message (sent from the client to the server once connected)
            </summary>
            <param name="userName">Name of the user.</param>
            <returns>
                <see cref="T:Griffin.Net.Authentication.Messages.AuthenticationHandshake"/>
            </returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.CreateServerPreAuthentication(Griffin.Net.Authentication.IUserAccount)">
            <summary>
                Create the message that are sent from the server to the client with the salts that should be used during the
                authentication.
            </summary>
            <param name="user">User that want to be authenticated</param>
            <returns>
                <see cref="T:Griffin.Net.Authentication.HashAuthenticator.Messages.AuthenticationHandshakeReply"/>
            </returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.CreateAuthentication(System.String)">
            <summary>
                The last authentication step. Contains the hashed authentication string
            </summary>
            <param name="token"></param>
            <returns>
                <see cref="T:Griffin.Net.Authentication.Messages.Authenticate"/>
            </returns>
        </member>
        <member name="M:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.CreateAuthenticationResult(Griffin.Net.Authentication.Messages.AuthenticateReplyState,System.String)">
            <summary>
                Sent by server to indicate how the authentication went
            </summary>
            <param name="state">How it went</param>
            <param name="authenticationToken"></param>
            <returns>
                <see cref="T:Griffin.Net.Authentication.Messages.AuthenticateReply"/>
            </returns>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.AuthenticationMessageFactory.Hasher">
            <summary>
            Used by the factory to generate salts.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.AuthenticationHandshake">
            <summary>
            Default implementation supporting both DataContract and the old .NET serializers.
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.IAuthenticationHandshake">
            <summary>
            Step one during the authentication steps.
            </summary>
            <remarks>
            Should be sent to the server directly after a successful connect.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticationHandshake.UserName">
            <summary>
            Name of the user that would like to authenticate
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.AuthenticationHandshake.UserName">
            <summary>
            Name of the user that would like to authenticate
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.HashAuthenticator.Messages.AuthenticationHandshakeReply">
            <summary>
                Default implementation supporting data contracts
            </summary>
        </member>
        <member name="T:Griffin.Net.Authentication.Messages.IAuthenticationHandshakeReply">
            <summary>
            Step two, server responds with salts.
            </summary>
            <remarks>
            Should be the reply from the server on the <see cref="T:Griffin.Net.Authentication.Messages.IAuthenticationHandshake"/> message.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticationHandshakeReply.AccountSalt">
            <summary>
            Salt that you have used to salt the password before storing it in the database.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.Messages.IAuthenticationHandshakeReply.SessionSalt">
            <summary>
            Used to prevent man in the middle attacks. You can use a random string, a guid or whatever you prefer.
            </summary>
            <remarks>
            <para>
            The string must however be unique for this session (client connection).
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Authentication.HashAuthenticator.Messages.AuthenticationHandshakeReply.AccountSalt">
            <summary>
                Salt that you have used to salt the password before storing it in the database.
            </summary>
        </member>
        <member name="P:Griffin.Net.Authentication.HashAuthenticator.Messages.AuthenticationHandshakeReply.SessionSalt">
            <summary>
                Used to prevent man in the middle attacks. You can use a random string, a guid or whatever you prefer.
            </summary>
            <remarks>
                The string must however be unique for this session (client connection).
            </remarks>
        </member>
        <member name="T:Griffin.Net.ChannelException">
            <summary>
            Channel failed to work as expected.
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.ChannelException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.Net.ChannelException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.ChannelException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Griffin.Net.ChannelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.ChannelException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Griffin.Net.Channels.BufferPreProcessorHandler">
            <summary>
            Delegate for <see cref="P:Griffin.Net.Channels.ITcpChannel.BufferPreProcessor"/>.
            </summary>
            <param name="channel">Channel that have received something</param>
            <param name="buffer">Buffer containing the processed bytes</param>
            <returns>Number of bytes process by the buffer pre processor (i.e. no one else should process those bytes)</returns>
        </member>
        <member name="T:Griffin.Net.ChannelTcpClient">
            <summary>
                Can talk with messaging servers (i.e. servers based on <see cref="T:Griffin.Net.ChannelTcpListener"/>).
            </summary>
            <remarks>
                <para>
                    You can use the <see cref="P:Griffin.Net.ChannelTcpClient.Filter"/> property if you want to have a callback for incoming messages.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.#ctor(Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.ChannelTcpClient"/> class.
            </summary>
            <param name="encoder">Used to encode outbound messages.</param>
            <param name="decoder">Used to decode inbound messages.</param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.#ctor(Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder,Griffin.Net.Buffers.IBufferSlice)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.ChannelTcpClient"/> class.
            </summary>
            <param name="encoder">Used to encode outbound messages.</param>
            <param name="decoder">Used to decode inbound messages.</param>
            <param name="readBuffer">Buffer used to receive bytes..</param>
            <exception cref="T:System.ArgumentNullException">
                encoder
                or
                decoder
                or
                readBuffer
            </exception>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.CloseAsync">
            <summary>
                Wait for all messages to be sent and close the connection
            </summary>
            <returns>Async task</returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)">
            <summary>
                Connects to remote end point.
            </summary>
            <param name="address">Address to connect to.</param>
            <param name="port">Remote port.</param>
            <returns>Async task</returns>
            <exception cref="T:System.InvalidOperationException">Socket is already connected</exception>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ConnectAsync(System.Net.IPAddress,System.Int32,System.TimeSpan)">
            <summary>
                Connects to remote end point.
            </summary>
            <param name="address">Address to connect to.</param>
            <param name="port">Remote port.</param>
            <param name="timeout">Maximum amount of time to wait for a connection.</param>
            <returns>Async task</returns>
            <exception cref="T:System.InvalidOperationException">Socket is already connected</exception>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ReceiveAsync">
            <summary>
                Receive a message
            </summary>
            <returns>Decoded message</returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ReceiveAsync``1">
            <summary>
                Receive a message
            </summary>
            <returns>Decoded message</returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>
                Receive a message
            </summary>
            <param name="cancellation">Token used to cancel the pending read operation.</param>
            <returns>
                Decoded message if successful; <c>default(T)</c> if cancellation is requested.
            </returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ReceiveAsync(System.TimeSpan)">
            <summary>
                Receives the asynchronous.
            </summary>
            <param name="timeout">Maximum amount of time to wait on a message</param>
            <returns>Decoded message</returns>
            <exception cref="T:Griffin.Net.ChannelException">
                Was signalled that something have been recieved, but found nothing in
                the in queue
            </exception>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.ReceiveAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Receive a message
            </summary>
            <param name="timeout">Maximum amount of time to wait on a message</param>
            <param name="cancellation">Token used to cancel the pending read operation.</param>
            <returns>
                Decoded message if successful; <c>default(T)</c> if cancellation is requested.
            </returns>
            <exception cref="T:Griffin.Net.ChannelException">
                Was signalled that something have been recieved, but found nothing in
                the in queue
            </exception>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient.SendAsync(System.Object)">
            <summary>
                Send message to the remote end point.
            </summary>
            <param name="message">message to send.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">message</exception>
            <remarks>
                <para>
                    All messages are being enqueued and sent in order. This method will return when the current message have been
                    sent. It
                </para>
                <para>
                    The method is thread safe and can be executed from multiple threads.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.ChannelTcpClient.Certificate">
            <summary>
                Set certificate if you want to use secure connections.
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpClient.Authenticator">
            <summary>
                Set if you want to authenticate against a server.
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpClient.IsConnected">
            <summary>
                Gets if channel is connected
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpClient.Filter">
            <summary>
                Delegate which can be used instead of <see cref="M:Griffin.Net.ChannelTcpClient.ReceiveAsync"/> or to inspect all incoming messages before they
                are passed to <see cref="M:Griffin.Net.ChannelTcpClient.ReceiveAsync"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpClient.BufferPreProcessor">
            <summary>
                Pre processes incoming bytes before they are passed to the message builder.
            </summary>
            <remarks>
                <para>
                    Can be used if you for instance use a custom authentication mechanism which needs to process incoming
                    bytes instead of deserialized messages.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Buffers.BufferSlice">
            <summary>
                Used to slice a larger buffer into smaller chunks.
            </summary>
        </member>
        <member name="T:Griffin.Net.Buffers.IBufferSlice">
            <summary>
            A slice of a larger buffer
            </summary>
            <remarks>
            <para>
            
            To reduce the amount of allocations we can allocate a large buffer and then slice it into smaller chunks. This interface represents a chunk.
            
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Offset">
            <summary>
            Where this slice starts
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Capacity">
            <summary>
            Number of bytes allocated for this slice
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Buffer">
            <summary>
            Buffer that this is a slice of.
            </summary>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlice.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.BufferSlice"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">Start offset in buffer.</param>
            <param name="count">Number of bytes allocated for this slice..</param>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;Offset+Count must be less than the buffer length.</exception>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Offset">
            <summary>
                Where this slice starts
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Capacity">
            <summary>
                AMount of bytes allocated for this slice.
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Buffer">
            <summary>
                Buffer that this slice is in.
            </summary>
        </member>
        <member name="T:Griffin.Net.Buffers.BufferSlicePool">
            <summary>
            Creates a large buffer and slices it.
            </summary>
            <remarks>
            <para>
            Thread safe, can be used to reuse slices.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Buffers.IBufferSlicePool">
            <summary>
            Represents a part of a larger byte buffer.
            </summary>
        </member>
        <member name="M:Griffin.Net.Buffers.IBufferSlicePool.Pop">
            <summary>
            Pop a new slice
            </summary>
            <returns>New slice</returns>
            <exception cref="T:Griffin.Net.Buffers.PoolEmptyException">There are no more free slices in the pool.</exception>
        </member>
        <member name="M:Griffin.Net.Buffers.IBufferSlicePool.Push(Griffin.Net.Buffers.IBufferSlice)">
            <summary>
            Return a slice to the pool
            </summary>
            <param name="bufferSlice">Slice retrieved using <see cref="M:Griffin.Net.Buffers.IBufferSlicePool.Pop"/>.</param>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.BufferSlicePool"/> class.
            </summary>
            <param name="sliceSize">How large each slice should be.</param>
            <param name="numberOfBuffers">The number of slices.</param>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.Pop">
            <summary>
            Get a new slice
            </summary>
            <returns>Slice</returns>
            <exception cref="T:Griffin.Net.Buffers.PoolEmptyException">Out of buffers. You are either not releasing used buffers or have allocated fewer buffers than allowed number of connected clients.</exception>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.Push(Griffin.Net.Buffers.IBufferSlice)">
            <summary>
            Enqueue a slice to be able to re-use it later
            </summary>
            <param name="bufferSlice">Slice to append</param>
            <exception cref="T:System.ArgumentNullException">bufferSlice</exception>
        </member>
        <member name="T:Griffin.Net.Buffers.PoolEmptyException">
            <summary>
                A object pool (or similar) have no more items to give out.
            </summary>
            <remarks>This exception typically occurs if the pool/stack is too small (too many concurrent operations) or if some code fails to return the item to the pool when done.</remarks>
        </member>
        <member name="M:Griffin.Net.Buffers.PoolEmptyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.PoolEmptyException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="T:Griffin.Net.Channels.ChannelData">
            <summary>
            Uses a concurrent dictionary to store all items.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.IChannelData">
            <summary>
            Used to store data in a connected channel.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.GetOrAdd(System.String,System.Func{System.String,System.Object})">
            <summary>
            Get or add a value
            </summary>
            <param name="key">key to get</param>
            <param name="addCallback">Should return value to add if the key is not found</param>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.TryUpdate(System.String,System.Object,System.Object)">
            <summary>
            Try updating a value
            </summary>
            <param name="key">Key for the value to update</param>
            <param name="newValue">Value to set</param>
            <param name="existingValue">Value that we've previously retrieved</param>
            <returns><c>true</c> if the existing value is the same as the one in the dictionary</returns>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.Clear">
            <summary>
            Remove all existing data.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.IChannelData.Item(System.String)">
            <summary>
            Get or set data
            </summary>
            <param name="key">Identifier (note that everyone with access to the channel can access the data, use careful naming)</param>
            <returns>Data if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ChannelData.GetOrAdd(System.String,System.Func{System.String,System.Object})">
            <summary>
            Get or add a value
            </summary>
            <param name="key">key to get</param>
            <param name="addCallback">Should return value to add if the key is not found</param>
            <returns>Item that was added or found</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ChannelData.TryUpdate(System.String,System.Object,System.Object)">
            <summary>
            Try updating a value
            </summary>
            <param name="key">Key for the value to update</param>
            <param name="newValue">Value to set</param>
            <param name="existingValue">Value that we've previously retrieved</param>
            <returns><c>true</c> if the existing value is the same as the one in the dictionary</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ChannelData.Clear">
            <summary>
            Remove all existing data.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ChannelData.Item(System.String)">
            <summary>
            Get or set data
            </summary>
            <param name="key">Identifier (note that everyone with access to the channel can access the data, use careful naming)</param>
            <returns>Data if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Channels.ClientCertificate">
            <summary>
            Client X.509 certificate, X.509 chain, and any SSL policy errors encountered
            during the SSL stream creation
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ClientCertificate.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.ClientCertificate"/> class.
            </summary>
            <param name="certificate">The certificate.</param>
            <param name="chain">Client security certificate chain.</param>
            <param name="sslPolicyErrors">Any SSL policy errors encountered during the SSL stream creation.</param>
            <exception cref="T:System.ArgumentNullException">
            certificate
            or
            chain
            </exception>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.Certificate">
            <summary>
            Client security certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.Chain">
            <summary>
            Client security certificate chain
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.SslPolicyErrors">
            <summary>
            Any SSL policy errors encountered during the SSL stream creation
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ClientSideSslStreamBuilder">
            <summary>
            Builder used to create SslStreams for client side applications.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ISslStreamBuilder">
            <summary>
            Used to build SSL streams (i.e. create and do the initial handshake)
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ISslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ClientSideSslStreamBuilder.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="commonName">the domain name of the server that you are connecting to</param>
        </member>
        <member name="M:Griffin.Net.Channels.ClientSideSslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ClientSideSslStreamBuilder.OnRemoteCertifiateValidation(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Used to validate the certificate that the server have provided.
            </summary>
            <param name="sender">Server.</param>
            <param name="certificate">The certificate.</param>
            <param name="chain">The chain.</param>
            <param name="sslpolicyerrors">The sslpolicyerrors.</param>
            <returns><c>true</c> if the certificate will be allowed, otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.CommonName">
            <summary>
            Typically the domain name of the server that you are connecting to.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.Certificate">
            <summary>
            Leave empty to use the server certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.Protocols">
            <summary>
            Allowed SSL protocols
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ChannelFailureHandler">
            <summary>
            Invoked by <see cref="T:Griffin.Net.Channels.ITcpChannel"/> if the <see cref="T:Griffin.Net.IMessageDecoder"/> fails to parse incoming message.
            </summary>
            <param name="channel">Channel that the decoder belongs to</param>
            <param name="error">Why the decoder failed</param>
            <remarks>
            <para>
            Typically the handler will send an error message and close the connection.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.DisconnectHandler">
            <summary>
            <see cref="T:Griffin.Net.Channels.ITcpChannel"/> got disconnected
            </summary>
            <param name="channel">Channel which got disconnected</param>
            <param name="exception">Exception  (<c>SocketException</c> for TCP errors)</param>
            <seealso cref="T:Griffin.Net.Channels.ITcpChannel"/>
        </member>
        <member name="T:Griffin.Net.Channels.EmptyEndpoint">
            <summary>
            Used when there are no connected endpoint for a channel
            </summary>
        </member>
        <member name="F:Griffin.Net.Channels.EmptyEndpoint.Instance">
            <summary>
            Instance representing an unassigned end point.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.EmptyEndpoint.ToString">
            <summary>
                Returns "None"
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Channels.EmptyEndpoint.AddressFamily">
            <summary>
                Gets the address family to which the endpoint belongs.
            </summary>
            <returns>
                <c>AddressFamily.Unspecified</c>
            </returns>
            <exception cref="T:System.NotImplementedException">
                Any attempt is made to get or set the property when the property is
                not overridden in a descendant class.
            </exception>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="UnmanagedCode, ControlEvidence" />
            </PermissionSet>
        </member>
        <member name="T:Griffin.Net.Channels.ISocketBuffer">
            <summary>
                Used to wrap <c>SocketAsyncEventArgs</c> to make everything testable (which <c>SocketAsyncEventArgs</c> isn't due
                to private setters and socket references).
            </summary>
            <seealso cref="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper"/>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)">
            <summary>
                Reuse the previously specified buffer, but change the offset/count of the bytes to send.
            </summary>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Number of bytes to send</param>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
                Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Number of bytes to send</param>
            <param name="capacity">Total number of bytes allocated for this slices</param>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Number of bytes to send</param>
            <remarks>Capacity will be set to same as <c>count</c>.</remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.BytesTransferred">
            <summary>
                Number of bytes which were received or transmitted in the last Socket operation
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Count">
            <summary>
                Number of bytes to receive or send in the next Socket operation.
            </summary>
            <seealso cref="P:Griffin.Net.Channels.ISocketBuffer.Offset"/>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Capacity">
            <summary>
                Number of bytes allocated for this buffer
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Buffer">
            <summary>
                Buffer used for transfers
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.BaseOffset">
            <summary>
                Offset in buffer were our allocated part starts
            </summary>
            <remarks>A buffer can have been divided between many channels. this index tells us where our slice starts.</remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Offset">
            <summary>
                Start offset for the next socket operation. (Typically same as BaseOffset unless this is a continuation of a
                partial message send).
            </summary>
            <seealso cref="P:Griffin.Net.Channels.ISocketBuffer.Count"/>
        </member>
        <member name="T:Griffin.Net.Channels.ITcpChannel">
            <summary>
                A channel is used to send and receive information over a socket.
            </summary>
            <remarks>
                <para>
                    Channels should be designed so that they can be reused after a client has disconnected. Hence you can be sure
                    that the state is cleared when the <c>Cleanup()</c> method is invoked. Buffers etc may still be being used,
                    but any internal send queue etc should be emptied.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be reused.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    sent directly with the transport protocol (like HTTP or MicroMsg).
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Close">
            <summary>
                Close channel
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.CloseAsync">
            <summary>
                Close channel asynchronously
            </summary>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.MessageSent">
            <summary>
                Channel has sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.ChannelFailure">
            <summary>
                Invoked if the decoder fails to handle an incoming message
            </summary>
            <remarks>
                <para>
                    The handler MUST close the connection once a reply has been sent.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.IsConnected">
            <summary>
                Checks if the channel is connected.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.ChannelId">
            <summary>
                Identity of this channel
            </summary>
            <remarks>
                Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.Data">
            <summary>
                Can be used to store information in the channel so that you can access it for later requests.
            </summary>
            <remarks>
                <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.BufferPreProcessor">
            <summary>
                Pre processes incoming bytes before they are passed to the message builder.
            </summary>
            <remarks>
                <para>
                    Can be used if you for instance use a custom authentication mechanism which needs to process incoming
                    bytes instead of deserialized messages.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.MessageHandler">
            <summary>
            <see cref="T:Griffin.Net.Channels.ITcpChannel"/> have sent or received a message.
            </summary>
            <param name="channel">Channel that did the work</param>
            <param name="message">Message. depends on which encoder/decoder was used.</param>
            <remarks>We uses delegates instead of regular events to make sure that there are only one subscriber and that it's configured once.</remarks>
        </member>
        <member name="T:Griffin.Net.Channels.SecureTcpChannel">
            <summary>
            Used to secure the transport.
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.#ctor(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder,Griffin.Net.Channels.ISslStreamBuilder)">
            <summary>
            
            </summary>
            <param name="readBuffer"></param>
            <param name="encoder"></param>
            <param name="decoder"></param>
            <param name="sslStreamBuilder">Used to wrap the socket with a SSL stream</param>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    MicroMessage framed directly.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Close">
            <summary>
            Close channel, wait for all messages to be sent.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.CloseAsync">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be reused.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.MessageSent">
            <summary>
                Channel has sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.ChannelFailure">
            <summary>
            Invoked if the decoder fails to handle an incoming message
            </summary>
            <remarks>
            <para>
            The handler MUST close the connection once a reply has been sent.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.IsConnected">
            <summary>
            Checks if the channel is connected.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.ChannelId">
            <summary>
            Identity of this channel
            </summary>
            <remarks>
            Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.Data">
            <summary>
            Can be used to store information in the channel so that you can access it for later requests.
            </summary>
            <remarks>
            <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.BufferPreProcessor">
            <summary>
            Pre processes incoming bytes before they are passed to the message builder.
            </summary>
            <remarks>
            Can be used if you for instance use a custom authentication mechanism which needs to process incoming
            bytes.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.OutboundMessageQueue">
            <summary>
            Queue used to store messages that are going to be sent to the remote end point.
            </summary>
            <remarks>
            <para>We use a queue so that the caller can fire and forget. We send all messages in order as soon as possible.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.ServerSideSslStreamBuilder">
            <summary>
            Used to build SSL streams for server side applications.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ServerSideSslStreamBuilder.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.ServerSideSslStreamBuilder"/> class.
            </summary>
            <param name="certificate">The certificate.</param>
            <exception cref="T:System.ArgumentNullException">certificate</exception>
        </member>
        <member name="M:Griffin.Net.Channels.ServerSideSslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ServerSideSslStreamBuilder.OnRemoteCertifiateValidation(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Works just like the <a href="http://msdn.microsoft.com/en-us/library/system.net.security.remotecertificatevalidationcallback(v=vs.110).aspx">callback</a> for <c>SslStream</c>
            </summary>
            <param name="sender"></param>
            <param name="certificate"></param>
            <param name="chain"></param>
            <param name="sslpolicyerrors"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.CheckCertificateRevocation">
            <summary>
            check if the certificate have been revoked.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.Protocols">
            <summary>
            Allowed protocols
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.UseClientCertificate">
            <summary>
            The client must supply a certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.Certificate">
            <summary>
            Certificate to use in this server.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper">
            <summary>
            The real implementation which uses <c>SocketAsyncEventArgs</c> internally.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.#ctor(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper"/> class.
            </summary>
            <param name="args">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/> instance containing the event data.</param>
            <exception cref="T:System.ArgumentNullException">args</exception>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Int32,System.Int32)">
            <summary>
            Set the bytes which currently should be transferred in the next I/O operation (or the bytes which were just received)
            </summary>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Number of bytes to send</param>
            <param name="capacity">Total number of bytes allocated for this slices</param>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Number of bytes to send</param>
            <remarks>
            Capacity will be set to same as <c>count</c>.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.BytesTransferred">
            <summary>
            Number of bytes which were transferred in the last I/O operation
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Count">
            <summary>
            Number of bytes in our buffer.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Capacity">
            <summary>
            Number of bytes which we can use in the buffer.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Buffer">
            <summary>
            Buffer to use (or rather a slice of it)
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.BaseOffset">
            <summary>
            Where our slice starts in the <see cref="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Buffer"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Offset">
            <summary>
            Current offset in the buffer.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.SocketBuffer">
            <summary>
                USed for the SecureTcpChannel as we can't use the Async socket methods with it :(
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketBuffer.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.TcpChannel">
            <summary>
            Represents a socket connection between two end points.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.#ctor(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Channels.TcpChannel"/> class.
            </summary>
            <param name="readBuffer">Buffer used for our reading.</param>
            <param name="encoder">Used to encode messages before they are put in the MicroMessage body of outbound messages.</param>
            <param name="decoder">
                Used to decode the body of incoming MicroMessages. The <c>MessageReceived</c> delegate will be
                overridden by this class.
            </param>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
                <para>
                    You must have specified a <see cref="P:Griffin.Net.Channels.TcpChannel.MessageReceived"/> delegate first.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    MicroMessage framed directly.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Close">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be reused.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.CloseAsync">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.HandleDisconnect(System.Net.Sockets.SocketError)">
            <summary>
            Detected a disconnect
            </summary>
            <param name="socketError">ProtocolNotSupported = decoder failure.</param>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.HandleDisconnect(System.Net.Sockets.SocketError,System.Exception)">
            <summary>
            Detected a disconnect
            </summary>
            <param name="socketError">ProtocolNotSupported = decoder failure.</param>
            <param name="exception">Why we got disconnected</param>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.OutboundMessageQueue">
            <summary>
            Used to enqueue outbound messages (to support asynchronous handling, i.e. enqueue more messages before the current one has been sent)
            </summary>
            <remarks>
            <para>
            This property exists so that you can switch implementation.  This is used by the HttpListener so that we can add support
            for message pipelining
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.MessageSent">
            <summary>
                Channel has sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.ChannelFailure">
            <summary>
                The channel failed to complete an IO operation
            </summary>
            <remarks>
                <para>
                    The handler MUST close the connection once a reply has been sent.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.ChannelId">
            <summary>
                Identity of this channel
            </summary>
            <remarks>
                Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.IsConnected">
            <summary>
            Gets if channel is connected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.Data">
            <summary>
                Can be used to store information in the channel so that you can access it for later requests.
            </summary>
            <remarks>
                <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.BufferPreProcessor">
            <summary>
            Pre processes incoming bytes before they are passed to the message builder.
            </summary>
            <remarks>
            Can be used if you for instance use a custom authentication mechanism which needs to process incoming
            bytes.
            </remarks>
        </member>
        <member name="T:Griffin.Net.ChannelTcpListener">
            <summary>
                Listens on one of the specified protocols
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.IMessagingListener">
            <summary>
            Used to listen on new messages
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessagingListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessagingListener.Stop">
            <summary>
            Stop the listener.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.ChannelFactory">
            <summary>
                Used to create channels. Default is <see cref="T:Griffin.Net.Channels.TcpChannelFactory"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.MessageReceived">
            <summary>
                Delegate invoked when a new message is received
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.MessageSent">
            <summary>
                Delegate invoked when a message has been sent to the remote end point
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.IMessagingListener.ClientConnected">
            <summary>
                A client has connected (nothing has been sent or received yet)
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.IMessagingListener.ClientDisconnected">
            <summary>
                A client has disconnected
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener.
            </summary>
            <remarks>
            This also pre-configures 20 channels that can be used and reused during the lifetime of 
            this listener.
            </remarks>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Stop">
            <summary>
                Stop the listener.
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Configure(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
                To allow the sub classes to configure this class in their constructors.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnClientConnected(Griffin.Net.Channels.ITcpChannel)">
            <summary>
                A client has connected (nothing has been sent or received yet)
            </summary>
            <param name="channel">Channel which we created for the remote socket.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnClientDisconnected(Griffin.Net.Channels.ITcpChannel,System.Exception)">
            <summary>
                A client has disconnected
            </summary>
            <param name="channel">Channel representing the client that disconnected</param>
            <param name="exception">
                Exception which was used to detect disconnect (<c>SocketException</c> with status
                <c>Success</c> is created for graceful disconnects)
            </param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
                Receive a new message from the specified client
            </summary>
            <param name="source">Channel for the client</param>
            <param name="msg">Message (as decoded by the specified <see cref="T:Griffin.Net.IMessageDecoder"/>).</param>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.LocalPort">
            <summary>
                Port that the server is listening on.
            </summary>
            <remarks>
                You can use port <c>0</c> in <see cref="M:Griffin.Net.ChannelTcpListener.Start(System.Net.IPAddress,System.Int32)"/> to let the OS assign a port. This method will then give you the
                assigned port.
            </remarks>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.ChannelFactory">
            <summary>
                Used to create channels. Default is <see cref="T:Griffin.Net.Channels.TcpChannelFactory"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.MessageReceived">
            <summary>
                Delegate invoked when a new message is received
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.MessageSent">
            <summary>
                Delegate invoked when a message has been sent to the remote end point
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ClientConnected">
            <summary>
                A client has connected (nothing has been sent or received yet)
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ClientDisconnected">
            <summary>
                A client has disconnected
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ListenerError">
            <summary>
                An internal error occurred
            </summary>
        </member>
        <member name="T:Griffin.Net.ChannelTcpListenerConfiguration">
            <summary>
            Configuration for <see cref="T:Griffin.Net.ChannelTcpListener"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListenerConfiguration.#ctor(System.Func{Griffin.Net.IMessageDecoder},System.Func{Griffin.Net.IMessageEncoder})">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.ChannelTcpListenerConfiguration"/> class.
            </summary>
            <param name="decoderFactory">Used to create an decoder for every new accepted connection.</param>
            <param name="encoderFactory">Used to create an encoder for every new accepted connection.</param>
            <exception cref="T:System.ArgumentNullException">
            decoderFactory
            or
            encoderFactory
            </exception>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.DecoderFactory">
            <summary>
            Factory used to produce a decoder for every connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.EncoderFactory">
            <summary>
            Factory used to produce an encoder for every connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.BufferPool">
            <summary>
            Pool used to allocate buffers for every client
            </summary>
            <remarks>
            Each client requires one buffer (for receiving).
            </remarks>
            <value>
            100 buffers of size 65535 bytes are allocated per default.
            </value>
        </member>
        <member name="T:Griffin.Net.ClientFilterResult">
            <summary>
            Result for <see cref="T:Griffin.Net.FilterMessageHandler"/>.
            </summary>
        </member>
        <member name="F:Griffin.Net.ClientFilterResult.Revoke">
            <summary>
            Revoke message (do not handle it)
            </summary>
        </member>
        <member name="F:Griffin.Net.ClientFilterResult.Accept">
            <summary>
            Accept message
            </summary>
        </member>
        <member name="T:Griffin.Net.FilterMessageHandler">
            <summary>
            Used to be able to determine if a certain message should be handled or not
            </summary>
            <param name="channel">Channel that received the message</param>
            <param name="message">Message to be processed.</param>
            <returns>Result</returns>
        </member>
        <member name="T:Griffin.Net.IMessageQueue">
            <summary>
                Used to enqueue outbound messages
            </summary>
            <remarks>
                <para>
                    As a socket must complete it's operations before the next message can be send we need to be able to queue
                    outbound messages
                    so that we have a chance to complete IO operations for each message.
                </para>
                <para>
                    Without this, the socket would probably throw errors on us due toe the asynchronous nature of this library
                    implementation
                </para>
                <para>
                    You can create your own implementation which could allow for prioritizing or so that messages are sent in the
                    same order as their corresponding request comes in (if the message processors are not completed in order)
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
                <para>
                    You must be able to enqueue all messages as the library use some internal messages for different operations
                    (like being able to close when all messages have been sent)
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.MessageQueue">
            <summary>
                Used to enqueue outbound messages
            </summary>
            <remarks>
                <para>
                    Implemented using a ConcurrentQueue.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.MessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.MessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.NamespaceDoc">
            <summary>
            Networking support. Allows you to easily build client/server applications.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.ClientConnectedEventArgs">
            <summary>
                Used by <see cref="E:Griffin.Net.ChannelTcpListener.ClientConnected"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.ClientConnectedEventArgs"/> class.
            </summary>
            <param name="channel">The channel.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.CancelConnection">
            <summary>
                Cancel connection, will make the listener close it.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.CancelConnection(System.IO.Stream)">
            <summary>
                Close the listener, but send a response (you are yourself responsible of encoding it to a message)
            </summary>
            <param name="response">Stream with encoded message (which can be sent as-is).</param>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.Channel">
            <summary>
                Channel for the connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.Response">
            <summary>
                Response (if the client may not connect)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.MayConnect">
            <summary>
                Determines if the client may connect.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.SendResponse">
            <summary>
            The library should send a response.
            </summary>
            <value>
            Default is <c>true</c>.
            </value>
        </member>
        <member name="T:Griffin.Net.Protocols.ClientDisconnectedEventArgs">
            <summary>
                Event arguments for <see cref="E:Griffin.Net.ChannelTcpListener.ClientDisconnected"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientDisconnectedEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.ClientDisconnectedEventArgs"/> class.
            </summary>
            <param name="channel">The channel that disconnected.</param>
            <param name="exception">The exception that was caught.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientDisconnectedEventArgs.Channel">
            <summary>
            Channel that was disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientDisconnectedEventArgs.Exception">
            <summary>
            Exception that was caught (is SocketException if the connection failed or if the remote end point disconnected).
            </summary>
            <remarks>
            <c>SocketException</c> with status <c>Success</c> is created for graceful disconnects.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication">
            <summary>
                Authenticates using a HTTP cookie
            </summary>
            <remarks>
                <para>
                    Do note that this implementation hashes the user IP address. That means that the cookie is not valid if the
                    user gets a new IP. This is done
                    to prevent cookie hijacking.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAuthenticator">
            <summary>
            Used to authenticate the user.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>User if successful; otherwise null.</returns>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">Http exceptions will generate a response. Use for instance 403 Forbidden if the user may not connect.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.#ctor(System.String,Griffin.Net.Protocols.Http.Authentication.IAccountService)">
            <summary>
                Create a new instance of <see cref="T:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication"/>.
            </summary>
            <param name="hashKey">Used to hash the ip address, recommended size is 64 bytes.</param>
            <param name="accountService">Used to load users</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
                Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
                Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>UserName if successful; otherwise null.</returns>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">403 Forbidden if the nonce is incorrect.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.CreateCookie(System.Net.EndPoint,System.String,System.Boolean)">
            <summary>
                Create a new cookie
            </summary>
            <param name="remoteEndPoint">End point that want's an authentication cookie</param>
            <param name="userName">User name of the authenticated user</param>
            <param name="isPersistent">Store cookie for 60 days</param>
            <returns>
                <c>HttpResponseCookie</c>
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.Encode(System.Net.EndPoint)">
            <summary>
                Hash end point
            </summary>
            <param name="remoteEndPoint">Endpoint to hash</param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.CookieName">
            <summary>
                Name of the  authenticationCookie
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.Encoding">
            <summary>
                TODO: why do we use an encoding and not Base64?
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.HashKey">
            <summary>
                Can be any length, but 64 bytes is recommended.
            </summary>
            <remarks>
                Used to hash the machine identity
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.AuthenticationScheme">
            <summary>
                Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.IWebSocketMessage">
            <summary>
            Interface for WebSocket messages
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.IWebSocketMessage.Opcode">
            <summary>
            Type of message
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.IWebSocketMessage.Payload">
            <summary>
            Message payload
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectEventArgs">
            <summary>
            WebSocket Connect Event which includes the handshake request
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Create a new instance of <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectEventArgs"/>
            </summary>
            <param name="channel">Channel that connected</param>
            <param name="request">Request that we received</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectEventArgs.Request">
            <summary>
            WebSocket handshake request
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs">
            <summary>
            WebSocket Connected Event which includes the handshake request and response
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a new isntance of <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs"/>
            </summary>
            <param name="channel">Channel used for transfers</param>
            <param name="request">Request (should contain the upgrade request)</param>
            <param name="response">Response (should include the upgrade confirmation)</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs.Channel">
            <summary>
            Channel for the connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs.Request">
            <summary>
            WebSocket handshake request
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketClientConnectedEventArgs.Response">
            <summary>
            WebSocket handshake response
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder">
            <summary>
            Decodes websocket messages (once the HTTP handshake have been completed)
            </summary>
        </member>
        <member name="T:Griffin.Net.IMessageDecoder">
            <summary>
                Decodes incoming bytes into something more useful
            </summary>
        </member>
        <member name="M:Griffin.Net.IMessageDecoder.Clear">
            <summary>
                Clear state to allow this decoder to be reused.
            </summary>
        </member>
        <member name="M:Griffin.Net.IMessageDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="P:Griffin.Net.IMessageDecoder.MessageReceived">
            <summary>
                A message has been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder"/> class.
            </summary>
            <param name="messageSerializer">Custom message serializer (typically inherits from <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder"/>.)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
            We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.Clear">
            <summary>
            Reset decoder state so that we can decode a new message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.OnHttpMessage(System.Object)">
            <summary>
            Intercept http messages and look for websocket upgrade requests
            </summary>
            <param name="message">message from http decoder</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketDecoder.MessageReceived">
            <summary>
                A message has been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder">
            <summary>
            Encodes web socket messages over  HTTP
            </summary>
        </member>
        <member name="T:Griffin.Net.IMessageEncoder">
            <summary>
                Message encoders are used to convert objects into binary form so that they can be transferred over a socket.
            </summary>
            <remarks>
                The format itself is determined by the protocol which is implemented. See all implementations.
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageEncoder.Prepare(System.Object)">
            <summary>
                Prepare the encoder so that the specified object can be encoded next.
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
            <remarks>
                The <c>buffer</c> variable is typically a wrapper around <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>, but may be something
                else if required.
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.IMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketEncoder.Clear">
            <summary>
            Reset encoder state for a new HTTP request.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketFin">
            <summary>
            Is final frame or not
            </summary>
            <remarks>
            <para>The specification for this flag can be found in http://tools.ietf.org/html/rfc6455#section-5.2.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketFin.More">
            <summary>
            There are more fragments
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketFin.Final">
            <summary>
            This is the final frame
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame">
            <summary>
            WebSocket frame
            </summary>
            <remarks>
            <para>
            The specification for this frame can be found at http://tools.ietf.org/html/rfc6455#section-5.2.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.FragmentLength">
            <summary>
            Maximum fragment length. (<value>65535</value>)
            Can be up to UInt64.MaxValue
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Unmask">
            <summary>
            Applies the current masking key on the payload
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Fin">
            <summary>
            Final frame or not
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Rsv1">
            <summary>
            Extension switch one
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Rsv2">
            <summary>
            Extension switch two
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Rsv3">
            <summary>
            Extension switch three
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Opcode">
            <summary>
            Type of frame
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Mask">
            <summary>
            Is frame masked
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.MaskingKey">
            <summary>
            Masking key
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.Payload">
            <summary>
            Payload of the frame
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.PayloadLength">
            <summary>
            Payload length
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketFrame.ExtPayloadLength">
            <summary>
            Extended payload length
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.HashWebSocketKey(System.String)">
            <summary>
            Hashes the client WebSocket key for the server
            </summary>
            <param name="webSocketKey"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.CreateWebSocketKey">
            <summary>
            Creates a new random WebSocket key for the client
            </summary>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.IsWebSocketUpgrade(Griffin.Net.Protocols.Http.IHttpMessage)">
            <summary>
            Check if http message is a valid WebSocket upgrade request
            </summary>
            <param name="httpMessage">message to check</param>
            <returns>true if message is a valid WebSocket upgrade request</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.CreateMaskingKey">
            <summary>
            Creates a new radom masking key
            </summary>
            <returns>masking key</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.ToBigEndianUInt16(System.Byte[])">
            <summary>
            Helper function to convert a byte array to a short using big endian
            </summary>
            <param name="value">byte array</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.ToBigEndianUInt64(System.Byte[])">
            <summary>
            Helper function to convert a byte array to a long using big endian
            </summary>
            <param name="value">byte array</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.GetBigEndianBytes(System.UInt16)">
            <summary>
            Helper function to convert a short to a byte array using big endian
            </summary>
            <param name="value">short</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUtils.GetBigEndianBytes(System.UInt64)">
            <summary>
            Helper function to convert a long to a byte array using big endian
            </summary>
            <param name="value">long</param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener">
            <summary>
                A HttpListener that automatically transitions all incoming requests to WebSocket protocol.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpListener">
            <summary>
            HTTP listener
            </summary>
            <remarks>
            <para>
            Will produce <see cref="T:Griffin.Net.Protocols.Http.HttpRequestBase"/> unless you change the <see cref="P:Griffin.Net.Protocols.Http.HttpListener.BodyDecoder"/> property, which will make the listener produce <see cref="T:Griffin.Net.Protocols.Http.HttpRequest"/> instead.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpListener"/> class.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpListener"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.OnClientConnected(Griffin.Net.Channels.ITcpChannel)">
            <summary>
            A client has connected (nothing has been sent or received yet)
            </summary>
            <param name="channel">Channel which we created for the remote socket.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
            Receive a new message from the specified client
            </summary>
            <param name="source">Channel for the client</param>
            <param name="msg">Message (as decoded by the specified <see cref="T:Griffin.Net.IMessageDecoder"/>).</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpListener.BodyDecoder">
            <summary>
            Used to decode the body of incoming request to form/files.
            </summary>
            <remarks>
            <para>
            Per default <c>null</c> which means that nothing will be done with the body by the library.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
                Create a new instance of <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener"/>.
            </summary>
            <param name="configuration">Custom server configuration</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.#ctor">
            <summary>
                Create a new instance of  <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
            Handles the upgrade
            </summary>
            <param name="source">Channel that we've received a request from</param>
            <param name="msg">Message received.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.WebSocketMessageReceived">
            <summary>
                WebSocket message received handler
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.WebSocketClientConnect">
            <summary>
                A websocket client have connected (websocket handshake request is complete)
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.WebSocketClientConnected">
            <summary>
                A websocket client have connected (websocket handshake response is complete)
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.Http.WebSocket.WebSocketListener.WebSocketClientDisconnected">
            <summary>
                A websocket client have disconnected
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketMask">
            <summary>
            Is data masked or not
            </summary>
            <remarks>
            <para>
            The specification for this mask can be found in http://tools.ietf.org/html/rfc6455#section-5.2.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketMask.Unmask">
            <summary>
            Data is not masked
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketMask.Mask">
            <summary>
            Data is masked
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketMessage">
            <summary>
            WebSocket message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketMessage.#ctor(Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode)">
            <summary>
            Creates a new WebSocket message with empty payload. This is useful for control messages such as PING, PONG and CLOSE
            </summary>
            <param name="opcode">opcode</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketMessage.#ctor(Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode,System.IO.Stream)">
            <summary>
            Create a new WebSocket message with predefined payload
            </summary>
            <param name="opcode">opcode</param>
            <param name="payload">payload</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketMessage.Opcode">
            <summary>
            Kind of web socket message
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketMessage.Payload">
            <summary>
            Received message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode">
            <summary>
            Type of a websocket frame.
            </summary>
            <remarks>
            <para>
            The specification for this op code can be found in http://tools.ietf.org/html/rfc6455#section-5.2 and http://tools.ietf.org/html/rfc6455#section-11.8.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Continuation">
            <summary>
            Equivalent to numeric value 0.
            Indicates a continuation frame.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Text">
            <summary>
            Equivalent to numeric value 1.
            Indicates a text frame.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Binary">
            <summary>
            Equivalent to numeric value 2.
            Indicates a binary frame.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Close">
            <summary>
            Equivalent to numeric value 8.
            Indicates a connection close frame.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Ping">
            <summary>
            Equivalent to numeric value 9.
            Indicates a ping frame.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketOpcode.Pong">
            <summary>
            Equivalent to numeric value 10.
            Indicates a pong frame.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketRequest">
            <summary>
            WebSocket request includes the initial handshake request
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.WebSocket.WebSocketRequest.Handshake">
            <summary>
            Cookies of the handshake request
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketResponse">
            <summary>
            WebSocket response
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketRsv">
            <summary>
                Websocket extension switch
            </summary>
            <remarks>
                <para>
                    The specification for this option can be found in http://tools.ietf.org/html/rfc6455#section-5.2 and
                    http://tools.ietf.org/html/rfc6455#section-5.8.
                </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketRsv.Off">
            <summary>
                Off
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.WebSocket.WebSocketRsv.On">
            <summary>
                On
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeRequest">
            <summary>
            HTTP request used to indicate that we want to use the WEBSOCKET protocol.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpRequestBase">
            <summary>
            HTTP request, but without any operations done of the content.
            </summary>
            <remarks>
            <para>
            the purpose with the split between this <c>Base</c> and the <c>HttpRequest</c> is that application servers,
            proxies etc are not interested in the content. This wasting memory on parsing the content will hurt performance
            a lot in a .NET environment.
            </para>
            <para>
            However, every time you've configured <see cref="T:Griffin.Net.Protocols.Http.HttpMessageDecoder"/> to use a <see cref="T:Griffin.Net.Protocols.Serializers.IMessageSerializer"/> like
            <see cref="T:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer"/> you can safely expect the request to be of type <c>HttpRequest</c>.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessage">
            <summary>
            Base class for HTTP requests and responses.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpMessage">
            <summary>
                Represents a request or response.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpMessage.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.StatusLine">
            <summary>
                First line in a HTTP message divided into parts (array with three items).
            </summary>
            <remarks>
                <para>The content of the line depends on if this is a HTTP request </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.HttpVersion">
            <summary>
                Version of the HTTP protocol
            </summary>
            <remarks>
                <para>
                    Typically <c>HTTP/1.1</c> but can also be the old version <c>HTTP/1.0</c> or the new draft <c>HTTP/2.0</c>
                    (aka SPDY)
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.Headers">
            <summary>
                All HTTP headers.
            </summary>
            <remarks>
                <para>Missing headers will return <c>null</c> as value</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.Body">
            <summary>
                Body in the HTTP message
            </summary>
            <remarks>
                <para>
                    The body has not been modified or parsed in any way. The actual stream is either a <c>MemoryStream</c> or
                    <c>FileStream</c> depending on the
                    size of the body.
                </para>
                <para>
                    The implementation of this interface should have the control over the specified stream. That is, the stream
                    will always be disposed by this library when the message has been processed.
                    Hence you have to make sure that we can take control over the stream that you've specified.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentLength">
            <summary>
                Length of the body in bytes.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentType">
            <summary>
                Content type without any parameters.
            </summary>
            <remarks>
                <para>
                    If you need to get the boundary etc, then use <c>request.Headers["Content-Type"]</c>.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentCharset">
            <summary>
                The encoding used in the document (if it's text of some sort)
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.HttpMessage.PipelineIndexKey">
            <summary>
                Used to be able to send responses in the same order as the request came in (if the web browser supports request
                pipelining)
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.HttpMessage.Iso85591">
            <summary>
            8559-1 encoding
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.#ctor(System.String)">
            <summary>
            </summary>
            <param name="httpVersion">Version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.OnHeaderSet(System.String,System.String)">
            <summary>
                Invoked every time a HTTP header is modified.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Value</param>
            <remarks>
                <para>Allows you to validate headers or modify the request when a specific header is set.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.StatusLine">
            <summary>
                Status line in a HTTP message divided into parts (array with three items).
            </summary>
            <remarks>
                <para>The content of the line depends on if this is a HTTP request </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.HttpVersion">
            <summary>
                Version of the HTTP protocol
            </summary>
            <remarks>
                <para>
                    Typically <c>HTTP/1.1</c> but can also be the old version <c>HTTP/1.0</c> or the new draft <c>HTTP/2.0</c>
                    (aka SPDY)
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.Headers">
            <summary>
            All HTTP headers.
            </summary>
            <remarks>
            Missing headers will return <c>null</c> as value
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.Body">
            <summary>
                Body in the HTTP message
            </summary>
            <remarks>
                <para>
                    The body has not been modified or parsed in any way. The actual stream is either a <c>MemoryStream</c> or
                    <c>FileStream</c> depending on the
                    size of the body.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentLength">
            <summary>
                Length of the body in bytes.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentType">
            <summary>
                Content type without encoding
            </summary>
            <remarks>
                <para>
                    To set encoding you have to use <c>httpMessage.Headers["content-type"] = "text/html; charset=utf8"</c> or
                    similar.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentCharset">
            <summary>
                The encoding used in the document (if it's text of some sort)
            </summary>
            <remarks>
                <para>
                    To set encoding you have to use <c>httpMessage.Headers["content-type"] = "text/html; charset=utf8"</c> or
                    similar.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpRequest">
            <summary>
            Represents a HTTP request
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpRequest.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.HttpMethod">
            <summary>
                Method which was invoked.
            </summary>
            <remarks>
                <para>Typically <c>GET</c>, <c>POST</c>, <c>PUT</c>, <c>DELETE</c> or <c>HEAD</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.Uri">
            <summary>
                Request UrI
            </summary>
            <remarks>
                <para>Is built using the <c>server</c> header and the path + query which is included in the request line</para>
                <para>If no <c>server</c> header is included "127.0.0.1" will be used as server.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.RemoteEndPoint">
            <summary>
            Address to the remote end point
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="httpMethod">Method like <c>POST</c>.</param>
            <param name="pathAndQuery">Absolute path and query string (if one exist)</param>
            <param name="httpVersion">HTTP version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
            <remarks>
            <para>
            If you override this method you have to copy the PipelineIndexKey header like this:
            <code>
             var pipeline = Headers[PipelineIndexKey];
             if (pipeline != null)
             {
                response.Headers[PipelineIndexKey] = pipeline;
             }        
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.OnHeaderSet(System.String,System.String)">
            <summary>
            Invoked every time a HTTP header is modified.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Value</param>
            <remarks>
            Used to build the URI when the HOST header comes.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.HttpMethod">
            <summary>
                Method which was invoked.
            </summary>
            <remarks>
                <para>Typically <c>GET</c>, <c>POST</c>, <c>PUT</c>, <c>DELETE</c> or <c>HEAD</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.Uri">
            <summary>
                Request UrI
            </summary>
            <remarks>
                <para>Is built using the <c>server</c> header and the path + query which is included in the request line</para>
                <para>If no <c>server</c> header is included "localhost" will be used as server.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.RemoteEndPoint">
            <summary>
            Address to the remote end point
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.StatusLine">
            <summary>
            Status line for requests is "HttpMethod PathAndQuery HttpVersion"
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.Cookies">
            <summary>
            Included cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeRequest.#ctor">
            <summary>
            Create a new instance of <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeRequest"/>.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeResponse">
            <summary>
            Used to confirm that we can switch to WEBSOCKETs from regular HTTP Requests.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponseBase">
            <summary>
            A HTTP response with minimal parsing.
            </summary>
            <remarks>
            <para>The purpose of this class is to do as little as possible with the response to make the processing more straightforward and without
            any unnessacary steps.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpResponse">
            <summary>
                A http response.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpResponse.StatusCode">
            <summary>
                HTTP status code. You typically choose one of <see cref="T:System.Net.HttpStatusCode"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpResponse.ReasonPhrase">
            <summary>
                Why the specified <see cref="P:Griffin.Net.Protocols.Http.IHttpResponse.StatusCode"/> was set.
            </summary>
            <remarks>
                <para>
                    The goal with the reason is to help the remote endpoint to understand why the specific code was chosen. i.e. it
                    allows you
                    to help the programmer to understand why a specific error code was set.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseBase.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponseBase"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="reasonPhrase">The reason phrase.</param>
            <param name="httpVersion">The HTTP version.</param>
            <exception cref="T:System.ArgumentNullException">reasonPhrase</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseBase.#ctor(System.Net.HttpStatusCode,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponseBase"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="reasonPhrase">The reason phrase.</param>
            <param name="httpVersion">The HTTP version.</param>
            <exception cref="T:System.ArgumentNullException">reasonPhrase</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusCode">
            <summary>
                HTTP status code. You typically choose one of <see cref="T:System.Net.HttpStatusCode"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.ReasonPhrase">
            <summary>
                Why the specified <see cref="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusCode"/> was set.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusLine">
            <summary>
            Status line for HTTP responses is "HttpVersion StatusCode ReasonPhrase"
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeResponse.#ctor(System.String)">
            <summary>
            Create a new instance of <see cref="T:Griffin.Net.Protocols.Http.WebSocket.WebSocketUpgradeResponse"/>
            </summary>
            <param name="webSocketKey">Key from the HTTP request.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Serializers.DecoderFailureException">
            <summary>
                A decoder failed to decode request/response body
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.DecoderFailureException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Serializers.DecoderFailureException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.DecoderFailureException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Serializers.DecoderFailureException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.DecoderFailureException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Serializers.DecoderFailureException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Serializers.FormAndFilesResult">
            <summary>
            Result from decoders.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Serializers.FormAndFilesResult.Files">
            <summary>
            Collection of files (or an empty collection)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Serializers.FormAndFilesResult.Form">
            <summary>
            HTTP form items (or an empty form)
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2">
            <summary>Provides a thread-safe priority queue data structure.</summary>
            <typeparam name="TKey">Specifies the type of keys used to prioritize values.</typeparam>
            <typeparam name="TValue">Specifies the type of elements in the queue.</typeparam>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.#ctor">
            <summary>Initializes a new instance of the ConcurrentPriorityQueue class.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Initializes a new instance of the ConcurrentPriorityQueue class that contains elements copied from the specified collection.</summary>
            <param name="collection">The collection whose elements are copied to the new ConcurrentPriorityQueue.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.Enqueue(`0,`1)">
            <summary>Adds the key/value pair to the priority queue.</summary>
            <param name="priority">The priority of the item to be added.</param>
            <param name="value">The item to be added.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.Enqueue(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds the key/value pair to the priority queue.</summary>
            <param name="item">The key/value pair to be added to the queue.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.TryDequeue(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to remove and return the next prioritized item in the queue.</summary>
            <param name="result">
            When this method returns, if the operation was successful, result contains the object removed. If
            no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.TryPeek(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to return the next prioritized item in the queue.</summary>
            <param name="result">
            When this method returns, if the operation was successful, result contains the object.
            The queue was not modified by the operation.
            </param>
            <returns>
            true if an element was returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.Clear">
            <summary>Empties the queue.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the elements of the collection to an array, starting at a particular array index.</summary>
            <param name="array">
            The one-dimensional array that is the destination of the elements copied from the queue.
            </param>
            <param name="index">
            The zero-based index in array at which copying begins.
            </param>
            <remarks>The elements will not be copied to the array in any guaranteed order.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.ToArray">
            <summary>Copies the elements stored in the queue to a new array.</summary>
            <returns>A new array containing a snapshot of elements copied from the queue.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#Concurrent#IProducerConsumerCollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#TryAdd(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Attempts to add an item in the queue.</summary>
            <param name="item">The key/value pair to be added.</param>
            <returns>
            true if the pair was added; otherwise, false.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#Concurrent#IProducerConsumerCollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#TryTake(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to remove and return the next prioritized item in the queue.</summary>
            <param name="item">
            When this method returns, if the operation was successful, result contains the object removed. If
            no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator for the contents of the queue.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents of the queue. It does not
            reflect any updates to the collection after GetEnumerator was called. The enumerator is safe to
            use concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the elements of the collection to an array, starting at a particular array index.</summary>
            <param name="array">
            The one-dimensional array that is the destination of the elements copied from the queue.
            </param>
            <param name="index">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.IsEmpty">
            <summary>Gets whether the queue is empty.</summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.Count">
            <summary>Gets the number of elements contained in the queue.</summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the ICollection is synchronized with the SyncRoot.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap">
            <summary>Implements a binary heap that prioritizes smaller values.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.#ctor">
            <summary>Initializes an empty heap.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.#ctor(Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue{`0,`1}.MinBinaryHeap)">
            <summary>Initializes a heap as a copy of another heap instance.</summary>
            <param name="heapToCopy">The heap to copy.</param>
            <remarks>Key/Value values are not deep cloned.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Clear">
            <summary>Empties the heap.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Insert(`0,`1)">
            <summary>Adds an item to the heap.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds an item to the heap.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Peek">
            <summary>Returns the entry at the top of the heap.</summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Remove">
            <summary>Removes the entry at the top of the heap.</summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.External.ConcurrentPriorityQueue`2.MinBinaryHeap.Count">
            <summary>Gets the number of objects stored in the heap.</summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpCookie">
            <summary>
            Create a new HTTP cookie
            </summary>
            <remarks>Typically a request cookie, since response cookies need more information.</remarks>
            <seealso cref="T:Griffin.Net.Protocols.Http.HttpResponseCookie"/>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpCookie">
            <summary>
            A cookie
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookie.Value">
            <summary>
            Gets value. 
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookie.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpCookie"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookie.Value">
            <summary>
            Gets value. 
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpCookieCollection`1">
            <summary>
            A collection of HTTP cookies
            </summary>
            <typeparam name="T">Type of cookie</typeparam>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpCookieCollection`1">
            <summary>
            Collection of cookies
            </summary>
            <typeparam name="T">Type of cookie</typeparam>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Add(`0)">
            <summary>
            Add a cookie.
            </summary>
            <param name="cookie">Cookie to add</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Remove(System.String)">
            <summary>
            Remove a cookie from the collection.
            </summary>
            <param name="cookieName">Name of cookie.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (<c>null</c> if not existing).
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Add(`0)">
            <summary>
            Adds the specified cookie.
            </summary>
            <param name="cookie">The cookie.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Remove(System.String)">
            <summary>
            Remove a cookie from the collection.
            </summary>
            <param name="cookieName">Name of cookie.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (<c>null</c> if not existing).
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpRequest">
            <summary>
            A HTTP request where the message content have been parsed into <c>Form</c> and <c>Files</c>.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpMessageWithForm">
            <summary>
            A message where the form have been decoded (or can be encoded for outbound messages)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessageWithForm.Form">
            <summary>
            Decoded HTTP body (along with <see cref="P:Griffin.Net.Protocols.Http.IHttpMessageWithForm.Files"/>)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessageWithForm.Files">
            <summary>
            Files from a multipart body
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequest.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="httpMethod">Method like <c>POST</c>.</param>
            <param name="pathAndQuery">Absolute path and query string (if one exist)</param>
            <param name="httpVersion">HTTP version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequest.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
            <remarks>
            <para>
            If you override this method you have to copy the PipelineIndexKey header like this:
            <code>
             var pipeline = Headers[PipelineIndexKey];
             if (pipeline != null)
             {
                response.Headers[PipelineIndexKey] = pipeline;
             }        
            </code>
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequest.Form">
            <summary>
            Submitted form items
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequest.Files">
            <summary>
            Submitted files
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication">
            <summary>
            Basic aithentication
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.#ctor(Griffin.Net.Protocols.Http.Authentication.IAccountService,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication"/> class.
            </summary>
            <param name="userService">The user service.</param>
            <param name="realm">The realm.</param>
            <exception cref="T:System.ArgumentNullException">
            userService
            or
            realm
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>Authenticated user if successful; otherwise null.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator">
            <summary>
            Implements Digest authentication.
            </summary>
            <remarks>Read RFC 2617 for more information</remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.DisableNonceCheck">
            <summary>
            Used by test classes to be able to use hardcoded values
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.#ctor(Griffin.Net.Protocols.Http.Authentication.IRealmRepository,Griffin.Net.Protocols.Http.Authentication.IAccountService)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator"/> class.
            </summary>
            <param name="realmRepository">Used to lookup the realm for a HTTP request</param>
            <param name="userService">Supplies users during authentication process.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>
            UserName if successful; otherwise null.
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">Invalid nonce/nc.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Encrypts parameters into a Digest string
            </summary>
            <param name="realm">Realm that the user want to log into.</param>
            <param name="userName">User logging in</param>
            <param name="password">Users password.</param>
            <param name="method">HTTP method.</param>
            <param name="uri">Uri/domain that generated the login prompt.</param>
            <param name="qop">Quality of Protection.</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">"Client Number used ONCE"</param>
            <returns>Digest encrypted string</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.GetHa1(System.String,System.String,System.String)">
            <summary>
            Generate a HA1 hash
            </summary>
            <param name="realm">Realm that the user want to authenticate in</param>
            <param name="userName">USername</param>
            <param name="password">Password</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="ha1">Md5 hex encoded "userName:realm:password", without the quotes.</param>
            <param name="ha2">Md5 hex encoded "method:uri", without the quotes</param>
            <param name="qop">Quality of Protection</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">Client number used once</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.GetMd5HashBinHex(System.String)">
            <summary>
            Gets the Md5 hash bin hex2.
            </summary>
            <param name="toBeHashed">To be hashed.</param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce">
            <summary>
            Used to keep track of a Digest authentication nonce
            </summary>
            <remarks>Only five attempts may be made.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce"/> class.
            </summary>
            <param name="expires">When nonce expires.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.Validate(System.Int32)">
            <summary>
            Check if the nonce can be used.
            </summary>
            <param name="value"></param>
            <returns>true if counter is currently unused and within the range; otherwise false;</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.PassedCounts">
            <summary>
            Gets all passed counts.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.LastUpdate">
            <summary>
            Gets time for last attempt.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.Expired">
            <summary>
            Gets if nonce has expired.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService">
            <summary>
            Monitors all nonces.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService"/> class.
            </summary>
            <param name="expiresTimeout">How long a nonce is valid, default is 15 seconds.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.IsValid(System.String,System.Int32)">
            <summary>
            Checks if a nonce is valid
            </summary>
            <param name="value">nonce value</param>
            <param name="counter">nc counter</param>
            <returns>true if nonce is valid; otherwise false.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.CreateNonce">
            <summary>
            Create a new nonce
            </summary>
            <returns>Created nonce.</returns>
            <remarks>Valid Time span is configured in the <see cref="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor(System.TimeSpan)"/> constructor. Default time is 15 seconds.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.Sweep(System.Object)">
            <summary>
            Remove expired nonces.
            </summary>
            <param name="state"></param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.HostAsRealmRepository">
            <summary>
            Uses <c>request.Uri.Host</c> as realm.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IRealmRepository">
            <summary>
            Returns the realm for a request.
            </summary>
            <remarks>Realms are used during authentication</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.HostAsRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAccountService">
            <summary>
            Provider returning user to be authenticated.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAccountService.Lookup(System.String,System.Uri)">
            <summary>
            Lookups the specified user
            </summary>
            <param name="userName">User name.</param>
            <param name="host">Typically web server domain name.</param>
            <returns>User if found; otherwise <c>null</c>.</returns>
            <remarks>
            User name can basically be anything. For instance name entered by user when using
            basic or digest authentication, or SID when using Windows authentication.
            </remarks>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">Typically with status code 403 if too many attempts have been made or if the user is not allowed.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAccountService.HashPassword(System.String,System.Uri,System.String)">
            <summary>
            Hash password to be able to do comparison
            </summary>
            <param name="userName"></param>
            <param name="host"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAccountService.ComparePassword(Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser,System.String)">
            <summary>
            Allows you to manage passwords by your self. Only works if the client supplies clear text passwords.
            </summary>
            <param name="user">User that your service returned from <c>Lookup</c>.</param>
            <param name="password">Password supplied by the client (web browser / http client)</param>
            <returns><c>true</c> if the user was authenticated</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser">
            <summary>
            USer stored in the database.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.Username">
            <summary>
            Gets or sets user name used during authentication.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.Password">
            <summary>
            Gets or sets unencrypted password.
            </summary>
            <remarks>
            Password as clear text. You could use <see cref="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.HA1"/> instead if your passwords
            are encrypted in the database.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.HA1">
            <summary>
            Gets or sets HA1 hash.
            </summary>
            <remarks>
            <para>
            Digest authentication requires clear text passwords to work. If you
            do not have that, you can store a HA1 hash in your database (which is part of
            the Digest authentication process).
            </para>
            <para>
            A HA1 hash is simply a Md5 encoded string: "UserName:Realm:Password". The quotes should
            not be included. Realm is the currently requested Host (as in <c>Request.Headers["host"]</c>).
            </para>
            <para>
            Leave the string as <c>null</c> if you are not using HA1 hashes.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory">
            <summary>
            Used to create <see cref="T:System.Security.Principal.IPrincipal"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory.Create(Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext)">
            <summary>
            Create a new prinicpal
            </summary>
            <param name="context">Context used to identify the user.</param>
            <returns>Principal to use</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IUserWithRoles">
            <summary>
            Used to be able to generate <see cref="T:System.Security.Principal.IPrincipal"/> directly.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IUserWithRoles.RoleNames">
            <summary>
            Get a list of all roles
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext">
            <summary>
            Context for <see cref="T:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.#ctor(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext"/> class.
            </summary>
            <param name="request">The request.</param>
            <param name="userName">user that have authenticated successfully.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.UserName">
            <summary>
            Gets the name of the user which was provided by the <see cref="T:Griffin.Net.Protocols.Http.Authentication.IAccountService"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.Request">
            <summary>
            Gets the HTTP request.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository">
            <summary>
            Uses a single realm for all requests.
            </summary>
            <example>
            <code>
            var digestAuthenticator = new DigestAuthenticator(new SingleRealmRepository("DragonsDen"), _myUserService);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository"/> class.
            </summary>
            <param name="name">Name of the realm.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BadRequestException">
            <summary>
                The request was malformed.
            </summary>
            <remarks>
                <para>Uses 400 as status code</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpException">
            <summary>
                A HTTP exception
            </summary>
            <remarks>
                HTTP exceptions will automatically generate a custom error page with the specified status code,
                opposed to all other exceptions which will generate a Internal Server Error.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpException.#ctor(System.Net.HttpStatusCode,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpException"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpException.#ctor(System.Int32,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpException"/> class.
            </summary>
            <param name="code">The code.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpException.#ctor(System.Net.HttpStatusCode,System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpException"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="errorMessage">The error message.</param>
            <param name="inner">The inner exception.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpException.HttpCode">
            <summary>
                Gets status code
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BadRequestException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.BadRequestException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BadRequestException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.BadRequestException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BadRequestException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.BadRequestException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponse">
            <summary>
            Complete HTTP response.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponse.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponse"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="reasonPhrase">The reason phrase.</param>
            <param name="httpVersion">The HTTP version.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponse.#ctor(System.Net.HttpStatusCode,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponse"/> class.
            </summary>
            <param name="statusCode">The status code.</param>
            <param name="reasonPhrase">The reason phrase.</param>
            <param name="httpVersion">The HTTP version.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponse.Cookies">
            <summary>
            Cookies to send to the server side
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer">
            <summary>
            Serializer for <c>application/x-www-form-urlencoded</c>
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Serializers.IMessageSerializer">
            <summary>
                Serialize or deserialize messages.
            </summary>
            <remarks>
                <para>
                    A suggestions is that you use the <c>Type.AssemblyQualifiedName</c> as the content name of your application
                    is .NET only.
                </para>
                <para>The methods must be isolated (i.e. should be able to call the same instance them from several threads).</para>
                <para>
                    The content type should follow the format defined by the HTTP specification (RFC2616) where the media type can
                    be followed by a semicolon and then
                    commaseparated key-value pairs. However, we might want to include the .NET type in the message which contains a
                    colon between the FullName and the Assembly. In the content type
                    we therefore need to replace it with a hypen. See example below
                </para>
                <code>
            application/json;type=Your.App.Namespace.SomeType-YourApp
            </code>
                <para>
                    That allows us to support media types which are used by HTTP and other protocols where other parameters are
                    included, for example:
                </para>
                <code>
            application/x-www-form-urlencoded;charset=windows-1250;type=Your.App.Namespace.SomeType-YourApp
            </code>
            <para>
            You can use <see cref="T:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue"/> if you want to extract the actual content type and it's parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
                Deserialize the content from the stream.
            </summary>
            <param name="contentType">
                Used to identify the object which is about to be deserialized. Specified by the
                <c>Serialize()</c> method when invoked in the other end point.
            </param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>Created object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
                Serialize an object to the stream.
            </summary>
            <param name="source">Object to serialize</param>
            <param name="destination">Stream that the serialized version will be written to</param>
            <param name="contentType">
                If you include the type name to it after the format name, for instance
                <c>json;type=YourApp.DTO.User-YourApp</c>
            </param>
            <returns>Content name (will be passed to the <see cref="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Deserialize(System.String,System.IO.Stream)"/> method in the other end)</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Serializers.IMessageSerializer.SupportedContentTypes">
            <summary>
                Content types that this serializer supports.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer.MimeType">
            <summary>
            The mimetype that this decoder is for.
            </summary>
            <value>application/x-www-form-urlencoded</value>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
            Serialize an object to the stream.
            </summary>
            <param name="source">Object to serialize</param>
            <param name="destination">Stream that the serialized version will be written to</param>
            <param name="contentType">If you include the type name to it after the format name, for instance <c>json;YourApp.DTO.User,YourApp</c></param>
            <returns>Content name (will be passed to the <see cref="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Deserialize(System.String,System.IO.Stream)"/> method in the other end)</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
            Deserialize the content from the stream.
            </summary>
            <param name="contentType">Used to identify the object which is about to be deserialized. Specified by the <c>Serialize()</c> method when invoked in the other end point.</param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>Created object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer.SupportedContentTypes">
            <summary>
                Content types that this serializer supports.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer">
            <summary>
                Can provide one or more decoders.
            </summary>
            <remarks>
                The default implementation constructor uses <see cref="T:Griffin.Net.Protocols.Http.Serializers.UrlFormattedMessageSerializer"/> and
                <see cref="T:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer"/>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
                Serialize an object to the stream.
            </summary>
            <param name="source">Object to serialize</param>
            <param name="destination">Stream that the serialized version will be written to</param>
            <param name="contentType">
                If you include the type name to it after the format name, for instance
                <c>json;YourApp.DTO.User,YourApp</c>
            </param>
            <returns>Content name (will be passed to the <see cref="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Deserialize(System.String,System.IO.Stream)"/> method in the other end)</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
                Deserialize the content from the stream.
            </summary>
            <param name="contentType">
                Used to identify the object which is about to be deserialized. Specified by the
                <c>Serialize()</c> method when invoked in the other end point.
            </param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>Created object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.Add(System.String,Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
                Add another handlers.
            </summary>
            <param name="mimeType">Mime type</param>
            <param name="decoder">The decoder implementation. Must be thread safe.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.DefaultEncoding">
            <summary>
                Encoding to use if not specified in the HTTP request.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Serializers.CompositeIMessageSerializer.SupportedContentTypes">
            <summary>
                Content types that this serializer supports.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Serializers.Mono.HttpMultipart">
             <summary>
             Stream-based multipart handling.
            
             In this incarnation deals with an HttpInputStream as we are now using
             IntPtr-based streams instead of byte [].   In the future, we will also
             send uploads above a certain threshold into the disk (to implement
             limit-less HttpInputFiles). 
             </summary>
             <remarks>
             Taken from HttpRequest in mono (http://www.mono-project.com)
             </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer">
            <summary>
                Decodes multipart files.
            </summary>
            <remarks>
                <para>
                    Uses <c>Environment.GetFolderPath(Environment.SpecialFolder.InternetCache)</c> as temporary storage. The folder
                    <c>/var/tmp/</c> is used if the special folder is not found.
                </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer.FormData">
            <summary>
                form-data
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer.MimeType">
            <summary>
                Returns <c>multipart/form-data</c>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
            Serialize an object to the stream.
            </summary>
            <param name="source">Object to serialize</param>
            <param name="destination">Stream that the serialized version will be written to</param>
            <param name="contentType">If you include the type name to it after the format name, for instance <c>json;YourApp.DTO.User,YourApp</c></param>
            <returns>Content name (will be passed to the <see cref="M:Griffin.Net.Protocols.Serializers.IMessageSerializer.Deserialize(System.String,System.IO.Stream)"/> method in the other end)</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
            Deserialize the content from the stream.
            </summary>
            <param name="contentType">Used to identify the object which is about to be deserialized. Specified by the <c>Serialize()</c> method when invoked in the other end point.</param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>Created object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Serializers.MultipartSerializer.SupportedContentTypes">
            <summary>
            Content types that this serializer supports.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessageDecoder">
            <summary>
                Decodes HTTP messages
            </summary>
            <remarks>
                <para>
                    Per default the body is not decoded. To change that behavior you should use the constructor that takes
                    a message serializer.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageDecoder.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpMessageDecoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageDecoder.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpMessageDecoder"/> class.
            </summary>
            <param name="messageSerializer">The message serializer.</param>
            <exception cref="T:System.ArgumentNullException">messageSerializer</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageDecoder.Clear">
            <summary>
                Reset decoder state so that we can decode a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessageDecoder.MessageReceived">
            <summary>
                A message has been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessageEncoder">
            <summary>
                Used to encode request/response into a byte stream.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpMessageEncoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponseCookie">
            <summary>
            Response cookies also have an expiration and the path that they are valid for.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IResponseCookie">
            <summary>
            Response cookies have to specify where and when they are valid.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.Domain">
            <summary>
            Gets domain that the cookie is valid under
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.ExpiresUtc">
            <summary>
            Gets when the cookie expires.
            </summary>
            <remarks><see cref="F:System.DateTime.MinValue"/> means that the cookie expires when the session do so.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.Path">
            <summary>
            Gets path that the cookie is valid under.
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseCookie.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponseCookie"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseCookie.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.Domain">
            <summary>
            Gets domain that the cookie is valid under
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.ExpiresUtc">
            <summary>
            Gets when the cookie expires.
            </summary>
            <remarks><see cref="F:System.DateTime.MinValue"/> means that the cookie expires when the session do so.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.Path">
            <summary>
            Gets path that the cookie is valid under.
            </summary>
            <remarks><c>null</c> means not specified.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHeaderCollection">
            <summary>
            Represents all headers that are being sent/received in a HTTP message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHeaderCollection.Contains(System.String)">
            <summary>
            Checks if the specified header exists in the collection
            </summary>
            <param name="name">Name, case insensitive</param>
            <returns><c>true</c> if found; otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHeaderCollection.Count">
            <summary>
            Number of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHeaderCollection.Item(System.String)">
            <summary>
            Get or set an header
            </summary>
            <param name="name">Name, case insensitive</param>
            <returns>
            Header if found; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpFile">
            <summary>
            A file included in a HTTP request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFile.Move(System.String)">
            <summary>
            Move the file
            </summary>
            <param name="destination">Destination (path and file name)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFile.Delete">
            <summary>
            Delete file
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.ContentType">
            <summary>
            Gets or sets content type.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.Name">
            <summary>
            Gets or sets name in form.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.OriginalFileName">
            <summary>
            Gets or sets name original file name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.TempFileName">
            <summary>
            Gets or sets filename for locally stored file.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpFileCollection">
            <summary>
            Collection of files
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Contains(System.String)">
            <summary>
            Checks if a file exists.
            </summary>
            <param name="name">Name of the file (form item name)</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Add(Griffin.Net.Protocols.Http.IHttpFile)">
            <summary>
            Add a new file.
            </summary>
            <param name="file">File to add.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Clear">
            <summary>
            Remove all files from disk.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFileCollection.Item(System.String)">
            <summary>
            Get a file
            </summary>
            <param name="name">Name in the HTTP form.</param>
            <returns>File if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFileCollection.Count">
            <summary>
            Gets number of files
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IParameter">
            <summary>
            Parameter in <see cref="T:Griffin.Net.Protocols.Http.IParameterCollection"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameter.Add(System.String)">
            <summary>
            Add a new parameter value
            </summary>
            <param name="value">Value to add</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Value">
            <summary>
            Gets *last* value.
            </summary>
            <remarks>
            Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Name">
            <summary>
            Gets or sets name.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Item(System.Int32)">
            <summary>
            Get one of the values.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Count">
            <summary>
            Get number of values
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IParameterCollection">
            <summary>
            Collection of parameters
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Get(System.String)">
            <summary>
            Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Exists(System.String)">
            <summary>
            Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameterCollection.Count">
            <summary>
            Gets number of parameters.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameterCollection.Item(System.String)">
            <summary>
            Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpCookieParser">
            <summary>
            Parses a request cookie header value.
            </summary>
            <remarks>This class is not thread safe.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Name_Before">
            <summary>
            Parse state method, remove all white spaces before the cookie name
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Name">
            <summary>
            Read cookie name until white space or equals are found
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Name_After">
            <summary>
            Remove all white spaces until colon is found
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Value_Before">
            <summary>
            Determine if the cookie value is quoted or regular.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Value">
            <summary>
            Read cookie value
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Value_Quoted">
            <summary>
            Read cookie value quoted
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Parse(System.String)">
            <summary>
            Parse cookie string
            </summary>
            <returns>A generated cookie collection.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.IsEOF">
            <summary>
            end of cookie string?
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpFile">
            <summary>
            A HTTP file in a request.
            </summary>
            <remarks>The temporary file will be deleted when the request/response ends.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Move(System.String)">
            <summary>
            Move the file
            </summary>
            <param name="destination">Destination (path and file name)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Delete">
            <summary>
            Delete file
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.Name">
            <summary>
            Gets or sets form element name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.OriginalFileName">
            <summary>
            Gets or sets client side file name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.ContentType">
            <summary>
            Gets or sets mime content type
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.TempFileName">
            <summary>
            Gets or sets full path to local file
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpFileCollection">
            <summary>
            Collection of files in a HTTP request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Contains(System.String)">
            <summary>
            Checks if a file exists.
            </summary>
            <param name="name">Name of the file (form item name)</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Add(Griffin.Net.Protocols.Http.IHttpFile)">
            <summary>
            Add a new file.
            </summary>
            <param name="file">File to add.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Clear">
            <summary>
            Remove all files from disk.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Item(System.String)">
            <summary>
            Get a file
            </summary>
            <param name="name">Name in form</param>
            <returns>File if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Count">
            <summary>
            Gets number of files
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue">
            <summary>
                Value for a http header
            </summary>
            <remarks>
                <para>
                    Created to take care of optional value parameters.
                </para>
            </remarks>
            <example>
            <code>
            var str =  "application/x-www-form-urlencoded;charset=windows-1250;type=Your.App.Namespace.SomeType-YourApp";
            var header = new HttpHeaderValue(str);
            var contentType = header.Value;                 // application/x-www-form-urlencoded
            var charset = header.Parameters["charset"];     // windows-1250
            var type = header.Parameters["type"];           // Your.App.Namespace.SomeType-YourApp
            </code>
            </example>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue"/> class.
            </summary>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">value</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue.Value">
            <summary>
                Gets value (parameters after semicolon is excluded)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue.Parameters">
            <summary>
                All parameters after the semi colon (if any).
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.ParameterCollection">
            <summary>
                Collection of parameters in a HTTP header.
            </summary>
            <remarks>
                <para>
                    Most of the HTTP headers can have parameters in the header value. typically they are stored as
                    <code>TheHeaderValue;and=some,parameters=true</code>
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Parse(System.String)">
            <summary>
            Parse string
            </summary>
            <param name="value">contains "a=b,c=d" etc</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Parse(System.String,Griffin.Net.Protocols.Http.Messages.ParameterCollection)">
            <summary>
            Parse string
            </summary>
            <param name="value">contains "a=b,c=d" etc</param>
            <param name="target">Collection to fill with the values</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Add(System.String,System.String)">
            <summary>
                Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Exists(System.String)">
            <summary>
                Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Get(System.String)">
            <summary>
                Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Clear">
            <summary>
                Remove all item
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Count">
            <summary>
                Gets number of parameters.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Item(System.String)">
            <summary>
                Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection">
            <summary>
                Collection of HTTP headers
            </summary>
            <remarks>The values are not encoded, you must encode them when serializing the message.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.#ctor(System.Action{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection"/> class.
            </summary>
            <param name="headerSetCallback">Callback invoked every time a new header is set.</param>
            <exception cref="T:System.ArgumentNullException">headerSetCallback</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Add(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. This implementation will IGNORE all subsequent headers</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Contains(System.String)">
            <summary>
            Checks if the specified header exists in the collection
            </summary>
            <param name="name">Name, case insensitive</param>
            <returns>
              <c>true</c> if found; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">name</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Count">
            <summary>
            Number of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Item(System.String)">
            <summary>
            Used to fetch headers
            </summary>
            <param name="name">Lower case name</param>
            <returns>header if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HeaderParser">
            <summary>
                Used to parse the HTTP header.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderParser"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.Parse(Griffin.Net.Channels.ISocketBuffer,System.Int32)">
            <summary>
                Will try to parse everything in the buffer
            </summary>
            <param name="buffer">Buffer to read from.</param>
            <param name="offset">Where to start parsing in the buffer.</param>
            <returns>offset where the parser ended.</returns>
            <remarks>
                <para>
                    Do note that the parser is for the header only. The <see cref="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.Completed"/> event will
                    indicate that there might be body bytes left in the buffer. You have to handle them by yourself.
                </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.Completed">
            <summary>
            The header part of the request/response has been parsed successfully. The remaining bytes is for the body
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.HeaderParsed">
            <summary>
            We've parsed a header and it's value.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.RequestLineParsed">
            <summary>
            We've parsed a request line, meaning that all headers is for a HTTP Request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.Reset">
            <summary>
            Reset parser state
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.ResetLineParsing">
            <summary>
            Resets the line parsing so that a new header can be parsed.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.MessageHeaderHandler">
            <summary>
            Callback for <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderParser"/>
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.MessageNameHandler">
            <summary>
            Callback for <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderParser"/> when a HTTP status line have been received.
            </summary>
            <param name="part1">HttpVerb or HttpVersion depending on if it's a request or a response</param>
            <param name="part2">PathAndQuery or StatusCode depending on if it's a request or a response.</param>
            <param name="part3">HttpVersion or StatusDescription depending on if it's a request or a response</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.Parameter">
            <summary>
                A parameter in a HTTP header field.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.Parameter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">
            name
            or
            value
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.Add(System.String)">
            <summary>
                Add a new parameter value
            </summary>
            <param name="value">Value to add</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
                A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Values">
            <summary>
                Gets a list of all values.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Value">
            <summary>
                Gets *last* value.
            </summary>
            <remarks>
                Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Name">
            <summary>
                Gets or sets name.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Item(System.Int32)">
            <summary>
                Get one of the values.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Count">
            <summary>
                Get number of values
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.ReaderResult">
            <summary>
            Result from <see cref="M:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions.ReadToEnd(System.IO.TextReader,System.String)"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ReaderResult.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.ReaderResult"/> class.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ReaderResult.Value">
            <summary>
            Value read
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ReaderResult.Delimiter">
            <summary>
            Found delimiter
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions">
            <summary>
            Extensions for the standard text reader
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions.ReadToEnd(System.IO.TextReader,System.String)">
            <summary>
            </summary>
            <param name="reader"></param>
            <param name="delimiters"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.UrlDecoder">
            <summary>
            Parses query string
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.UrlDecoder.Parse(System.IO.TextReader,Griffin.Net.Protocols.Http.IParameterCollection)">
            <summary>
            Parse a query string
            </summary>
            <param name="reader">string to parse</param>
            <param name="parameters">Parameter collection to fill</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>reader</c> is <c>null</c>.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.UrlDecoder.Parse(System.String)">
            <summary>
            Parse a query string
            </summary>
            <param name="queryString">string to parse</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>queryString</c> is <c>null</c>.</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.PipelinedMessageQueue">
            <summary>
                A priority message queue which uses <c>ConcurrentPriorityQueue</c> from Microsoft
                (http://blogs.msdn.com/b/pfxteam/archive/2010/04/04/9990342.aspx)
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.PipelinedMessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.PipelinedMessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Range">
            <summary>
                Represents a HTTP range.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Range.#ctor(System.Int32,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Range"/> class.
            </summary>
            <param name="position">The position to start at in the stream/file.</param>
            <param name="count">Number of bytes in this range.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Range.#ctor(System.String,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Range"/> class.
            </summary>
            <param name="range">The range <c>"bytes "</c> should not be included.</param>
            <param name="streamLength">Total size of stream/file</param>
            <example>
                Last 100 bytes
                <code>
            -100
            </code>
                Specific range
                <code>
            100-199
            </code>
                From index 200 and the rest
                <code>
            200-
            </code>
            </example>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Range.Read(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
                Reads from the specified stream and puts the content in the specified byte buffer.
            </summary>
            <param name="source">Read the range from this stream.</param>
            <param name="buffer">Buffer to copy stream bytes to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="count">Number of bytes available to write to in the buffer.</param>
            <returns></returns>
            <remarks>
                The stream must support seeking since this method will move to our range position before
                start reading. Do note that the move is only made for the first read. Make sure that the position isn't changed
                until
                everything have been read in this range.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Range.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
                A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Range.IsDone">
            <summary>
                Gets value indicating if everything have been read using the <see cref="M:Griffin.Net.Protocols.Http.Range.Read(System.IO.Stream,System.Byte[],System.Int32,System.Int32)"/> method.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Range.Count">
            <summary>
                Gets number of bytes to read
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Range.EndPosition">
            <summary>
                Gets where to stop read
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Range.Position">
            <summary>
                Gets start position
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.RangeCollection">
            <summary>
            Collection of ranges which have been specified in the Range header.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.RangeCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.RangeCollection.Parse(System.String,System.Int32)">
            <summary>
            Parse range header value
            </summary>
            <param name="header">The "Range" header value</param>
            <param name="streamLength">File size (or size of the entire stream)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.RangeCollection.ToHtmlHeaderValue(System.Int32)">
            <summary>
            Create a string which is valid as value in the Content-Range header.
            </summary>
            <param name="streamLength">Length of the stream.</param>
            <returns><c>bytes X/Y</c></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.RangeCollection.TotalLength">
            <summary>
            Total length of all ranges (i.e. the number of bytes to transfer)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.RangeCollection.Item(System.Int32)">
            <summary>
            Get one of the ranges.
            </summary>
            <param name="index">Zero based index</param>
            <returns>Range</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.RangeCollection.Count">
            <summary>
            Gets number of ranges
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ITcpChannelFactory">
            <summary>
            Used to create channels.
            </summary>
            <remarks>
            <para>Can be used to adjust how all lower level functions should work, like protecting everything with SSL</para>
            <para></para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
            Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
            Create a new queue which is used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageClient">
            <summary>
                A client implementation for transferring objects over the MicroMessage protocol
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageClient.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageClient"/> class.
            </summary>
            <param name="serializer">The serializer.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageClient.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer,Griffin.Net.Channels.ClientSideSslStreamBuilder)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageClient"/> class.
            </summary>
            <param name="serializer">The serializer.</param>
            <param name="sslStreamBuilder">The SSL stream builder.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageClient.ConnectAsync(System.Net.IPAddress,System.Int32)">
            <summary>
                Connect to server
            </summary>
            <param name="address">The address.</param>
            <param name="port">The port.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
                Socket is already connected
                or
                There is already a pending connect.
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageClient.ReceiveAsync">
            <summary>
                Receive an object
            </summary>
            <returns>completion task</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageClient.SendAsync(System.Object)">
            <summary>
                Send an object
            </summary>
            <param name="message">Message to send</param>
            <returns>completion task (completed once the message have been delivered).</returns>
            <remarks>
                <para>All objects are enqueued and sent in order as soon as possible</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder">
            <summary>
            Decode messages encoded with <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/>.
            </summary>
            <remarks>
            <para>As <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> can out-of-the-box send <c>Stream</c>-drived classes and <c>byte[]</c> arrays this class
            has to handle that too.
            </para>
            <para>
            Streams will always be either <c>MemoryStream</c> or <c>FileStream</c> depending of the content-length. Same things goes for messages
            which are sent as <c>byte[]</c> arrays. They will also be received as streams.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.Version">
            <summary>
            Protocol version
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.FixedHeaderLength">
            <summary>
            Size of the fixed header: version (1), content length (4), type name length (1) = 8
            </summary>
            <remarks>
            The header size field is not included in the actual header count as it always have to be read to 
            get the actual header size.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder"/> class.
            </summary>
            <param name="serializer">The serializer used to decode the message that is being transported with MicroMsg.</param>
            <exception cref="T:System.ArgumentNullException">serializer</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.Clear">
            <summary>
            Reset the decoder so that we can parse a new message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
            Process bytes that we've received on the socket.
            </summary>
            <param name="buffer">Buffer to process.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.MessageReceived">
            <summary>
            A new message have been received.
            </summary>
            <remarks>
            <para>The message will be a deserialized message or a <c>Stream</c> derived object (if the sender sent a <c>Stream</c> or a <c>byte[]</c> array).</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder">
            <summary>
                Takes any object that the serializer supports and transfers it over the wire.
            </summary>
            <remarks>
                The encoder also natively supports <c>byte[]</c> arrays and <c>Stream</c> derived objects (as long as the stream
                have a size specified). These objects
                will be transferred without invoking the serializer.
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Version">
            <summary>
                PROTOCOL version
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.FixedHeaderLength">
            <summary>
                Size of the fixed header: version (1), content length (4), type name length (1) = 8
            </summary>
            <remarks>
                The header size field is not included in the actual header count as it always have to be read to
                get the actual header size.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> class.
            </summary>
            <param name="serializer">
                Serializer used to serialize the messages that should be sent. You might want to pick a
                serializer which is reasonable fast.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer,Griffin.Net.Buffers.IBufferSlice)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> class.
            </summary>
            <param name="serializer">
                Serializer used to serialize the messages that should be sent. You might want to pick a
                serializer which is reasonable fast.
            </param>
            <param name="bufferSlice">Used when sending information.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                bufferSlice; At least the header should fit in the buffer, and the header
                can be up to 520 bytes in the current version.
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Serialize message and sent it add it to the buffer
            </summary>
            <param name="args">Socket buffer</param>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks>
                <c>true</c> if the message have been sent successfully; otherwise <c>false</c>.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.NamespaceDoc">
            <summary>
                MicroMessage is a small message format with a binary header.
            </summary>
            <remarks>
            <para>
            The header was designed to be backwards compatible and support newer versions. The contents of the body is unspecified and up to the peers to decide.
            </para>
                The header contains the following fields:
                <list type="table">
                    <item>
                        <term>Headerlength</term>
                        <description><c>ushort</c>, number of bytes that are for the header. First byte is directly after this field. <para>This field was added
            to be able to include new features without affecting previous versions</para></description>
                    </item>
                    <item>
                        <term>Version</term>
                        <description><c>byte</c>, Defines the version of the micro protocol. Current version is 1.</description>
                    </item>
                    <item>
                        <term>ContentLength</term>
                        <description><c>int</c>, Defines the length of the body. The body starts directly after the header.</description>
                    </item>
                    <item>
                        <term>Typelength</term>
                        <description><c>ubyte</c>, Defines the length of the next header value.</description>
                    </item>
                    <item>
                        <term>TypeName</term>
                        <description>
                            Fully qualified assembly name of the type that is our payload.
                            <para>
                                The default encoding of the name is UTF8. You may use another encoding (to support foreign characters in the type names), but then it's important that you communicate out the encoding.
                            </para>
                        </description>
                    </item>
                </list>
                <para>
                    To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Serializers.DataContractMessageSerializer">
            <summary>
                Uses the DataContract XML serializer.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Serializers.DataContractMessageSerializer.MimeType">
            <summary>
                <c>application/x-datacontract</c>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.DataContractMessageSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
            Serialize an object to the stream.
            </summary>
            <param name="source">Object to serialize</param>
            <param name="destination">Stream that the serialized version will be written to</param>
            <param name="contentType">If you include the type name to it after the format name, for instance
            <c>json;type=YourApp.DTO.User-YourApp</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Serializers.DataContractMessageSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
            Deserialize the content from the stream.
            </summary>
            <param name="contentType">Used to identify the object which is about to be deserialized. Specified by the
            <c>Serialize()</c> method when invoked in the other end point.</param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>
            Created object
            </returns>
            <exception cref="T:System.ArgumentNullException">contentType</exception>
            <exception cref="T:System.FormatException">Failed to build a type from ' + contentType + '.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Serializers.DataContractMessageSerializer.SupportedContentTypes">
            <summary>
                Content types that this serializer supports.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageTcpListener">
            <summary>
            Server for the MicroMsg protocol
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageTcpListener.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageTcpListener"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageTcpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageTcpListener"/> class.
            </summary>
            <param name="configuration">Configuration to use.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">
            <summary>
                Failed to handle STOMP request
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.BadRequestException.#ctor(Griffin.Net.Protocols.Stomp.IFrame,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException"/> class.
            </summary>
            <param name="request">The request.</param>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.BadRequestException.Request">
            <summary>
                Frame that was not successfully handled.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.FrameExtensions">
            <summary>
            Extension methods for frames
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.FrameExtensions.CreateReceiptIfRequired(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Check if the 
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.IStompClient">
            <summary>
            Represents a connection / client session.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.IsFramePending(System.String)">
            <summary>
            Check if we are waiting on a ACK/NACK for the specified frame.
            </summary>
            <param name="messageId">Message id</param>
            <returns><c>true</c> if we are waiting on an ack/nack; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.GetSubscription(System.String)">
            <summary>
            Find our subscription
            </summary>
            <param name="messageId">A message which should have been distributed using a MESSAGE frame</param>
            <returns>Subscription</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Failed to find a subscription where the message '{0}' is pending (waiting for an ack/nack). Is the subscription really set to use 'client' or 'client-individual' acks?</exception>
            <exception cref="T:System.ArgumentNullException">messageId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.EnqueueInTransaction(System.String,System.Action,System.Action)">
            <summary>
            Enqueue work in an existing transaction (i.e. you must have invoked <c>BeginTransaction()</c> first)
            </summary>
            <param name="transactionId">Transaction identifier</param>
            <param name="commitAction">Action that will be invoked when the transaction is committed.</param>
            <param name="rollbackAction"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)">
            <summary>
            Begin a new transaction
            </summary>
            <param name="transactionId">Identifier. Must be unique within the same client connection</param>
            <exception cref="T:System.InvalidOperationException">Transaction has already been started.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.CommitTransaction(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RollbackTransaction(System.String)">
            <summary>
            Rollback a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SubscriptionExists(System.String)">
            <summary>
            Checks if a subscription have been created (typically using the "SUBSCRIBE" frame).
            </summary>
            <param name="subscriptionId">Subscription identifier (arbitrary string as specified by the client)</param>
            <returns><c>true</c> if the subscription exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Add a new subscription
            </summary>
            <param name="subscription">Subscription that the client requested</param>
            <remarks>
            The client can have one or more active subscriptions in the same connection. And all subscriptions may have their own AckType. 
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RemoveSubscription(System.String)">
            <summary>
            Remove a subscription (if it exists)
            </summary>
            <param name="subscriptionId">Identifier as specified when the subscription was created using a "SUBSCRIBE" frame.</param>
            <returns>Remove the subscription</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SetAsAuthenticated(System.String)">
            <summary>
            We have successfully authenticated this client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.Send(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Send a frame to the client.
            </summary>
            <param name="frame">A server side frame</param>
            <exception cref="T:System.InvalidOperationException">If one attempted to send a client frame.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.HasActiveTransactions">
            <summary>
            Determines if there are one or more active transactions.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SessionKey">
            <summary>
            Identifier which was created during the authentication process.
            </summary>
            <remarks>Authentication is always required, no matter if a user/pass is supplied or not.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RemoteEndpoint">
            <summary>
            Address from where the client is connected.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.IStompQueue">
            <summary>
                A queue contract for the STOMP protocol
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompQueue.Enqueue(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
                Put a message in our queue.
            </summary>
            <param name="message"></param>
            <remarks>
                Messages within transactions will be put on hold until the transaction is commited.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompQueue.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Add a new subscription
            </summary>
            <param name="subscription"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompQueue.Unsubscribe(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Unsubscribe on this queue.
            </summary>
            <param name="subscription"></param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompQueue.Name">
            <summary>
                Name of the queue as defined by the standard specification
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.ISubscriptionSubscriber">
            <summary>
            Wants to receive events from the subscription
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ISubscriptionSubscriber.OnMessageExpired">
            <summary>
            A message has not been delivered within the specified time frame
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager">
            <summary>
            Transaction manager.
            </summary>
            <remarks>
            All transaction ids must only be unique within the scope of a client connection.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)">
            <summary>
            Begin a new transaction
            </summary>
            <param name="transactionId">Identifier. Must be unique within the same client connection</param>
            <exception cref="T:System.InvalidOperationException">Transaction has already been started.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Enqueue(System.String,System.Action,System.Action)">
            <summary>
            Enqueue work in an existing transaction (i.e. you must have invoked <c>BeginTransaction()</c> first)
            </summary>
            <param name="transactionId">Transaction identifier</param>
            <param name="commitTask">Action that will be invoked when the transaction is committed.</param>
            <param name="rollbackTask"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Rollback(System.String)">
            <summary>
            Rollback a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Commit(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Cleanup">
            <summary>
            Remove all existing transactions (rollback all)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.HasActiveTransactions">
            <summary>
            Determines if there are one or more active transactions.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.AbortHandler">
            <summary>
            Rollback transaction
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.IFrameHandler">
            <summary>
            Used to process incoming frames
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.IFrameHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>Frame to send back; <c>null</c> if no message should be returned;</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">Frame was not well formed or contains invalid information.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.AbortHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back; <c>null</c> if no message should be returned;
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">Missing the 'transaction' header in the frame.</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.AckHandler">
            <summary>
            Receiver acks that he have received a message.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.AckHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">
            Missing the 'id' header in the frame. Required so that we know which message that the ACK is for.
            or
            </exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.BeginHandler">
            <summary>
            Begin a new transaction
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.BeginHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back; <c>null</c> if no message should be returned;
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">Missing the 'transaction' header in the frame.</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.CommitHandler">
            <summary>
            Commit transaction
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.CommitHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back; <c>null</c> if no message should be returned;
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">Missing the 'transaction' header in the frame.</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler">
            <summary>
            CONNECT frame. 
            </summary>
            <remarks>
            <para>
            Used instead of the initial STOMP frame for earlier versions.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IAuthenticationService,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler"/> class.
            </summary>
            <param name="authenticationService">The authentication service.</param>
            <param name="serverName">Name of the server.</param>
            <exception cref="T:System.ArgumentNullException">
            authenticationService
            or
            serverName
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back; <c>null</c> if no message should be returned;
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler.CheckCredentials(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame,Griffin.Net.Protocols.Stomp.IFrame@)">
            <summary>
            
            </summary>
            <param name="client"></param>
            <param name="request"></param>
            <param name="errorFrame"></param>
            <returns><c>true</c> means that we should exist.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.DisconnectHandler">
            <summary>
                Client want to disconnect.
            </summary>
            <remarks>
                FRAME is sent to make sure that all previous FRAMES have been processed.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.DisconnectHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
                Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
                Frame to send back; <c>null</c> if no message should be returned;
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">
                Missing the 'receipt' header in the frame. It's required so that we can notify you when the DISCONNECT frame has
                been received.
                or
                Got pending transactions. Just close the socket to abort them, or send proper commits/rollbacks before the
                DISCONNECT frame..
            </exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.NackHandler">
            <summary>
            Processes the NACK frame
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.NackHandler.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.NackHandler"/> class.
            </summary>
            <param name="queueRepository">The queue repository.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.NackHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Removes the frame from the client pending list and adds it back to the queue
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">
            Missing the 'id' header in the frame. Required so that we know which message that the NACK is for.
            or
            </exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SendHandler">
            <summary>
            Takes care of messages that a client want to send to a queue.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SendHandler.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SendHandler"/> class.
            </summary>
            <param name="queueRepository">The queue repository.</param>
            <exception cref="T:System.ArgumentNullException">queueRepository</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SendHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back; <c>null</c> if no message should be returned;
            </returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SubscribeHandler">
            <summary>
            Takes care of the SUBSCRIBE frame.
            </summary>
            <remarks>
            <para>
            Adds the current connection to the queue subscribers.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SubscribeHandler.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SubscribeHandler"/> class.
            </summary>
            <param name="queueRepository">The queue repository.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SubscribeHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Client that sent the frame</param>
            <param name="request">Frame to process</param>
            <returns>Frame to send back</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException"></exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.UnsubscribeHandler">
            <summary>
            Stop receiving messages from a queue
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.UnsubscribeHandler.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.UnsubscribeHandler"/> class.
            </summary>
            <param name="queueRepository">The queue repository.</param>
            <exception cref="T:System.ArgumentNullException">queueRepository</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.UnsubscribeHandler.Process(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Process an inbound frame.
            </summary>
            <param name="client">Connection that received the frame</param>
            <param name="request">Inbound frame to process</param>
            <returns>
            Frame to send back
            </returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.BadRequestException">
            Missing the ID header in the frame.
            or
            </exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">
            <summary>
            Something was not found, like a queue.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.NotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.IAuthenticationService">
            <summary>
            Contract for authentication service
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.IAuthenticationService.Login(System.String,System.String)">
            <summary>
            Login 
            </summary>
            <param name="user">User name (ascii)</param>
            <param name="passcode">Password (encrypted if the provider supports it)</param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.IAuthenticationService.IsActivated">
            <summary>
            Activated
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository">
            <summary>
            Data source for queues.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository.Get(System.String)">
            <summary>
            Fetch a queue
            </summary>
            <param name="queueName"></param>
            <returns>Queue</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Queue was not found</exception>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.LoginResponse">
            <summary>
            Response for a login attempt.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.LoginResponse.IsSuccessful">
            <summary>
            successful login
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.LoginResponse.Token">
            <summary>
            session token
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.LoginResponse.Reason">
            <summary>
            Why it failed.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository">
            <summary>
            Stores queues in memory. 
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository.Add(Griffin.Net.Protocols.Stomp.Broker.StompQueue)">
            <summary>
            Adds a queue to the repository.
            </summary>
            <param name="queue">The queue.</param>
            <exception cref="T:System.ArgumentNullException">queue</exception>
            <exception cref="T:System.ArgumentException">Queue must have a name;queue.Name</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository.Get(System.String)">
            <summary>
            Fetch a queue
            </summary>
            <param name="queueName">Name of the queue</param>
            <returns>
            Queue
            </returns>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Queue ' + queueName + ' do not exist</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.NoAuthenticationService">
            <summary>
            Simply says that authentication is not activated (i.e. should be skipped)
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager">
            <summary>
            Takes care of transactions for a specific connection.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Begin(System.String)">
            <summary>
            Begin a new transaction
            </summary>
            <param name="transactionId">Identifier. Must be unique within the same client connection</param>
            <exception cref="T:System.InvalidOperationException">Transaction ' + transactionId + ' have already been started.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Enqueue(System.String,System.Action,System.Action)">
            <summary>
            Enqueue work in an existing transaction (i.e. you must have invoked <c>BeginTransaction()</c> first)
            </summary>
            <param name="transactionId">Transaction identifier</param>
            <param name="commitTask">Action that will be invoked when the transaction is committed.</param>
            <param name="rollbackTask"></param>
            <exception cref="T:System.ArgumentNullException">
            transactionId
            or
            commitTask
            or
            rollbackTask
            </exception>
            <exception cref="T:System.InvalidOperationException">Transaction ' + transactionId +
            ' do not exist (or have been committed/rolled back).</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Rollback(System.String)">
            <summary>
            Rollback a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
            <exception cref="T:System.InvalidOperationException">Transaction ' + transactionId +
                                                                ' do not exist (or have been committed/rolled back).</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Commit(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
            <exception cref="T:System.InvalidOperationException">Transaction ' + transactionId +
                                                                ' do not exist (or have been committed/rolled back).</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Cleanup">
            <summary>
                Remove all existing transactions (rollback all)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.HasActiveTransactions">
            <summary>
                Determines if the connection have active transactions.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.StompBroker">
            <summary>
                Broker that allows end points to subscribing on queues to deliver and receive messages.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompBroker.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.StompBroker"/> class.
            </summary>
            <param name="repository">
                Used to provide all queues that this broker is for. There is a built in class,
                <see cref="T:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository"/>, which you can use.
            </param>
            <exception cref="T:System.ArgumentNullException">repository</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompBroker.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start broker to be able to receive incoming connections.
            </summary>
            <param name="address">Address to bind to</param>
            <param name="port">Port to accept connections on.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompBroker.AuthenticationService">
            <summary>
                Service used to authenticate incoming connections.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompBroker.ServerName">
            <summary>
                Name of the server.
            </summary>
            <value>
                Should be in the format "ServerName/versionNumber".
            </value>
            <example>
                Griffin Queue/1.0
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompBroker.LocalPort">
            <summary>
                Port that the server is listening on.
            </summary>
            <remarks>
                You can use port <c>0</c> in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.StompBroker.Start(System.Net.IPAddress,System.Int32)"/> to let the OS assign a port. This method will then give you the
                assigned port.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.StompClient">
            <summary>
                Implementation of <see cref="T:Griffin.Net.Protocols.Stomp.Broker.IStompClient"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.#ctor(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Protocols.Stomp.Broker.ITransactionManager)">
            <summary>
            </summary>
            <param name="channel"></param>
            <param name="transactionManager">
                Must be unique for this client. i.e. the transaction ids used in this client is not
                globally unique
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
                Add a new subscription
            </summary>
            <param name="subscription">Subscription that the client requested</param>
            <exception cref="T:System.ArgumentNullException">subscription</exception>
            <remarks>
                The client can have one or more active subscriptions in the same connection. And all subscriptions may have their
                own AckType.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.RemoveSubscription(System.String)">
            <summary>
                Removes the subscription.
            </summary>
            <param name="id">The id.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">id</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.SetAsAuthenticated(System.String)">
            <summary>
                We have successfully authenticated this client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.BeginTransaction(System.String)">
            <summary>
                Begins the transaction.
            </summary>
            <param name="transactionId">The transaction id.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.RollbackTransaction(System.String)">
            <summary>
                Rollbacks the transaction.
            </summary>
            <param name="transactionId">The transaction id.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.CommitTransaction(System.String)">
            <summary>
                Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.Send(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
                Send a frame to the client.
            </summary>
            <param name="frame">A server side frame</param>
            <exception cref="T:System.ArgumentNullException">frame</exception>
            <exception cref="T:System.InvalidOperationException">If one attempted to send a client frame.</exception>
            <remarks>
                Messages sent directly through the client are not being modified in any way. If you want to get ack, receipts etc,
                send through a subscription instead.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.IsFramePending(System.String)">
            <summary>
                Determines
            </summary>
            <param name="messageId"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.SubscriptionExists(System.String)">
            <summary>
            Checks if the specified subscription have been added previously.
            </summary>
            <param name="id">subscription id</param>
            <returns><c>true</c> if subscription have been added already; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.EnqueueInTransaction(System.String,System.Action,System.Action)">
            <summary>
            enqueue client in the specified transaction. I.e. move all pending messages back to queue if transaction fails.
            </summary>
            <param name="transactionId">Transaction to enlist in</param>
            <param name="commitAction">What to do if transaction succeeds</param>
            <param name="rollbacAction">What to do if transaction fails</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.GetSubscription(System.String)">
            <summary>
                find the subscription where the specified message is pending (i.e. waiting to be acked/nacked).
            </summary>
            <param name="messageId">The message id.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">messageId</exception>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">
                Failed to find a subscription where the message '{0}' is pending (waiting for an
                ack/nack). Is the subscription really set to use 'client' or 'client-individual' acks?
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.Cleanup">
            <summary>
            Reset state for this object (to prepare for handling another connection).
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.AckMessages(System.String)">
            <summary>
            Ack all messages before the given sequence number
            </summary>
            <param name="messageId">Message sequence number</param>
            <returns>Subscription that the messages belonged to.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.IsForChannel(Griffin.Net.Channels.ITcpChannel)">
            <summary>
            Checks of this client is for the specified TCP connection
            </summary>
            <param name="channel">Connection to take</param>
            <returns><c>true</c> if connection is the same; otherwise <c>false.</c></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.IsAuthenticated">
            <summary>
                Gets if this client has got the CONNECT/STOMP header and got authenticated.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.Channel">
            <summary>
                Channel used for communication
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.SessionKey">
            <summary>
                Identifier for this specific connection
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.RemoteEndpoint">
            <summary>
                Address from where the client is connected.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.HasActiveTransactions">
            <summary>
                Returns if this client has one or more active transactions
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.StompQueue">
            <summary>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.#ctor(Griffin.Net.Protocols.Stomp.Broker.ITransactionManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.StompQueue"/> class.
            </summary>
            <param name="transactionManager">The transaction manager.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Enqueue(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
                Put a message in our queue.
            </summary>
            <param name="message"></param>
            <remarks>
                Messages within transactions will be put on hold until the transaction is commited.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Stop">
            <summary>
            Stop processing messages in queue
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Add a client subscription
            </summary>
            <param name="subscription">Subscription that we should deliver messages to.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Unsubscribe(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Unsubscribe on this queue.
            </summary>
            <param name="subscription"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Requeue(System.Collections.Generic.IEnumerable{Griffin.Net.Protocols.Stomp.IFrame})">
            <summary>
                Will put all frames first in the queue again
            </summary>
            <param name="frame"></param>
            <remarks>
                Should only be used for queues that got one client and where the message ordering is important.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Name">
            <summary>
            Queue name
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Subscription">
            <summary>
            A list of all queues that a client want to receive messages from.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.#ctor(Griffin.Net.Protocols.Stomp.Broker.IStompClient,System.String)">
            <summary>
            
            </summary>
            <param name="client">Client that the subscription belongs to</param>
            <param name="id">Arbitrary string as specified by the client.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.Send(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Enqueue another message for delivery.
            </summary>
            <param name="frame">Frame to deliver</param>
            <exception cref="T:System.ArgumentNullException">frame</exception>
            <exception cref="T:System.InvalidOperationException">
            Only MESSAGE frames may be sent through a subscription.
            or
            Is either waiting on an ACK/NACK for the current message, or you've tried to send too many messages per second without acking them.
            or
            You've tried to send too many messages per second. Adjust the MaxMessagesPerSecond property.
            or
            Client already have more then 20 pending messages. Start ACK them.
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.Ack(System.String)">
            <summary>
            Ack a sent message
            </summary>
            <param name="id">ACK id</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.Nack(System.String)">
            <summary>
            Nack messages
            </summary>
            <param name="id">ACK sequence number</param>
            <returns>A list of frames that should be returned to the queue.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.IsMessagePending(System.String)">
            <summary>
            Checkes if the specified message is already pending.
            </summary>
            <param name="messageId">Message id</param>
            <returns><c>true</c> if message have already been enqueued for delivery; otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.Id">
            <summary>
            Arbitrary string as specified by the client.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.QueueName">
            <summary>
            Name of the queue.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.AckType">
            <summary>
            How each message should be acknowledged by the subscribing client
            </summary>
            <remarks>
            <c>client</c> = accumulative acknowledgment (i.e. all messages up to the specified one is ACK:ed). <c>client-individual</c>, each specific message must be acked. <c>auto</c> = All messages are
            considered ACK:ed as soon as they are sent.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.IsPending">
            <summary>
            Messages have been delivered but not yet ACKed by the client
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.IsReady">
            <summary>
            May still send messages (i.e. have not been throttled and have ACK-ed enough messages)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.IsThrottled">
            <summary>
            Checks if we have sent too many messages per second.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.MaxMessagesPerSecond">
            <summary>
            Amount of messages which can be sent to a client per second.
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.Stomp.Broker.Subscription.BecameIdle">
            <summary>
            All messages have been delivered, we have nothing more to do.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Transaction">
            <summary>
            A batch of messages
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Transaction.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Broker.Transaction"/> class.
            </summary>
            <param name="transactionId">The transaction identifier.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Transaction.Add(System.Action,System.Action)">
            <summary>
            Add a state subscriber
            </summary>
            <param name="commitTask">Action to execute once committing</param>
            <param name="rollbackTask">Action to take if rolling back</param>
            <exception cref="T:System.ArgumentNullException">
            commitTask
            or
            rollbackTask
            </exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Transaction.Rollback">
            <summary>
            Rollback transaction.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Transaction.Commit">
            <summary>
            Commit transaction.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Transaction.Id">
            <summary>
            Transaction identifier
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.FrameExtensions">
            <summary>
            Extension methods for Tasks
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.FrameExtensions.CreateAck(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Create a ACK from the specified message
            </summary>
            <param name="request">The request.</param>
            <returns>Generated ACK frame</returns>
            <exception cref="T:System.ArgumentNullException">request</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.FrameExtensions.CreateError(Griffin.Net.Protocols.Stomp.IFrame,System.String)">
            <summary>
            Create an error FRAME, include details from the faulty frame.
            </summary>
            <param name="request">Faulty frame</param>
            <param name="errorDescription">What happened</param>
            <returns>ERROR frame</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.FrameExtensions.CreateNack(Griffin.Net.Protocols.Stomp.IFrame,System.String)">
            <summary>
            Create a NACK frame
            </summary>
            <param name="request">Request to generate NACK from</param>
            <param name="errorDescription">Why we NACK</param>
            <returns>
            NACK frame
            </returns>
            <exception cref="T:System.ArgumentNullException">
            request
            or
            errorDescription
            </exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.BasicFrame">
            <summary>
                Base class for STOMP frames.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.IFrame">
            <summary>
                A message according to the STOMP specification.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.IFrame.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IFrame.Headers">
            <summary>
                A collection of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IFrame.Body">
            <summary>
                Application message
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IFrame.ContentLength">
            <summary>
                Size of the body
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IFrame.Name">
            <summary>
                Name of the STOMP frame
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Frames.BasicFrame"/> class.
            </summary>
            <param name="name">The name.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.Headers">
            <summary>
                A collection of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.Body">
            <summary>
                Application message
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.ContentLength">
            <summary>
                Size of the body
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.Name">
            <summary>
                Name of the STOMP frame
            </summary>
            <exception cref="T:System.ArgumentNullException">value</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.FrameHeaderHandler">
            <summary>
            Delegate used to process header line in a frame.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Header value</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.FrameNameHandler">
            <summary>
            Parsed the frame name.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection">
            <summary>
                Collection of STOMP headers
            </summary>
            <remarks>The values are not encoded, you must encode them when serializing the message.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.IHeaderCollection">
            <summary>
            Collection of STOMP headers
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.IHeaderCollection.Contains(System.String)">
            <summary>
            Checks if the collection contains the specified header.
            </summary>
            <param name="name">Name of the header</param>
            <returns><c>true</c> if found; otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IHeaderCollection.Count">
            <summary>
            Amount of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.IHeaderCollection.Item(System.String)">
            <summary>
            Access the value of a header.
            </summary>
            <param name="name">Name of the header</param>
            <returns>value if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.Add(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. This implementation will IGNORE all subsequent headers</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.Contains(System.String)">
            <summary>
            Checks if the collection contains the specified header.
            </summary>
            <param name="name">Name of the header</param>
            <returns>
              <c>true</c> if found; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.Count">
            <summary>
            Amount of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.String"/> with the specified name.
            </summary>
            <value>
            The <see cref="T:System.String"/>.
            </value>
            <param name="name">The name.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">value</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.HeaderParser">
            <summary>
                Used to parse the STOMP header.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Frames.HeaderParser"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Parse(Griffin.Net.Channels.ISocketBuffer,System.Int32)">
            <summary>
                Will try to parse everything in the buffer
            </summary>
            <param name="buffer">Buffer to read from.</param>
            <param name="offset">offset where the parser ended.</param>
            <remarks>
                <para>
                    Do note that the parser is for the header only. The <see cref="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Completed"/> event will
                    indicate that there might be body bytes left in the buffer. You have to handle them by yourself.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Reset">
            <summary>
                Reset parser state
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.ResetLineParsing">
            <summary>
                Completed parsing a header line, reset so we can parse another one.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Completed">
            <summary>
                The header part of the request/response has been parsed successfully. The remaining bytes is for the body
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.HeaderParsed">
            <summary>
                We've parsed a header and it's value.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.FrameNameParsed">
            <summary>
                The frame method has been parsed.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.ParseException">
            <summary>
            Failed to parse a header or similar.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.Server.StompError">
            <summary>
            ERROR frame
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.Server.StompError.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Frames.Server.StompError"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.Server.StompError.ReceiptId">
            <summary>
                If the erroneous frame included a receipt header, the ERROR frame SHOULD set the receipt-id header to match the value of the receipt header of the frame which the error is related to.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.Server.StompError.Message">
            <summary>
                Short description of what went wrong.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompClientLight">
            <summary>
            Used to talk with a STOMP server.
            </summary>
            <remarks>
            This client can only parse STOMP frames, it doesn't know what they mean.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompClientLight.#ctor(Griffin.Net.Protocols.Serializers.IMessageSerializer)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.StompClientLight"/> class.
            </summary>
            <param name="serializer">The serializer used to encode/decode body.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompDecoder">
            <summary>
            Decode incoming bytes into STOMP frames.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompDecoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.StompDecoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompDecoder.Clear">
            <summary>
            Clear state to allow this decoder to be reused.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.StompDecoder.MessageReceived">
            <summary>
                A message has been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompEncoder">
            <summary>
                Encode STOMP frames for delivery
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.StompEncoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompTcpListener">
            <summary>
            Listens on STOMP messages from a client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompTcpListener.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.StompTcpListener"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompTcpListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
            Receive a new message from the specified client
            </summary>
            <param name="source">Channel for the client</param>
            <param name="msg">Message (as decoded by the specified <see cref="T:Griffin.Net.IMessageDecoder"/>).</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompTcpListener.OnClientConnected(Griffin.Net.Channels.ITcpChannel)">
            <summary>
            A client has connected (nothing has been sent or received yet)
            </summary>
            <param name="channel">Channel which we created for the remote socket.</param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Strings.StringDecoder">
            <summary>
            Decodes messages that are represented as strings.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringDecoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Strings.StringDecoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringDecoder.Clear">
            <summary>
            Reset decoder state.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Strings.StringDecoder.Encoding">
            <summary>
            Text encoding to use.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Strings.StringDecoder.MessageReceived">
            <summary>
                A message has been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Strings.StringEncoder">
            <summary>
            Encodes strings using UTF8 and sends them over the network with a binary header (<c>int</c>).
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Prepare(System.Object)">
            <summary>
                Prepare the encoder so that the specified object can be encoded next.
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
            <remarks>
                The <c>buffer</c> variable is typically a wrapper around <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>, but may be something
                else if required.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.TcpChannelFactory">
            <summary>
                Creates a <see cref="T:Griffin.Net.Channels.TcpChannel"/>.
            </summary>
            <remarks>
                <para>
                    Allows you to provide your own custom channels to be able to control the IO operations that this library uses.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
                Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
                Create a new queue which is used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="T:Griffin.Net.Channels.SecureTcpChannelFactory">
            <summary>
            Used to create secure channels for our library.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannelFactory.#ctor(Griffin.Net.Channels.ISslStreamBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.SecureTcpChannelFactory"/> class.
            </summary>
            <param name="sslStreamBuilder">The SSL stream builder.</param>
            <exception cref="T:System.ArgumentNullException">sslStreamBuilder</exception>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
            Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
            Create a new queue which is used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="T:Griffin.ObjectExtensions">
            <summary>
            Extension methods for object.
            </summary>
        </member>
        <member name="M:Griffin.ObjectExtensions.ToDictionary(System.Object)">
            <summary>
                Turn anonymous object to dictionary
            </summary>
            <param name="data">Anonymous object</param>
            <returns>Dictionary</returns>
        </member>
        <member name="T:Griffin.QueueFullException">
            <summary>
                Queue is full and no more items may be enqueued.
            </summary>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:Griffin.QueueFullException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <PermissionSet>
              <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
              <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
              </PermissionSet>
        </member>
        <member name="P:Griffin.QueueFullException.QueueName">
            <summary>
                Name of the queue that is full.
            </summary>
        </member>
        <member name="T:Griffin.Reflection.ExpressionExtensions">
            <summary>
                Small helpers for expressions
            </summary>
        </member>
        <member name="M:Griffin.Reflection.ExpressionExtensions.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Get property information.
            </summary>
            <typeparam name="TSource">Entity type.</typeparam>
            <typeparam name="TProperty">Expression pointing at the property.</typeparam>
            <param name="propertyLambda">The property lambda.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">
            </exception>
        </member>
        <member name="T:Griffin.Security.IPasswordHasher">
            <summary>
                Used to hash passwords allowing different parts of Griffin.Framework to reuse the hashing to provide features like
                authentication.
            </summary>
        </member>
        <member name="M:Griffin.Security.IPasswordHasher.Compare(System.String,System.String)">
            <summary>
                Compare two hashes.
            </summary>
            <param name="hashedPassword1">First hash</param>
            <param name="hashedPassword2">Second hash</param>
            <returns>
                Allows us to make sure that all comparisons take about the same time so that the comparison is not exited
                early if the hashes differ in the beginning.
            </returns>
        </member>
        <member name="M:Griffin.Security.IPasswordHasher.CreateSalt">
            <summary>
                Generate a salt that can be used to hash passwords.
            </summary>
            <returns>Generated salt</returns>
        </member>
        <member name="M:Griffin.Security.IPasswordHasher.HashPassword(System.String,System.String)">
            <summary>
                Hash password using the specified salt
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
            <returns></returns>
            <remarks>
                <para>
                    Implementations should hashed passwords by using colon as separator.
                    <code>Hash(string.Format("{0}:{1}", password, salt))</code>
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Security.PasswordHasherRfc2898">
            <summary>
                Uses <c>RNGCryptoServiceProvider</c> to generate the salt and <c>Rfc2898DeriveBytes</c> for hashing.
            </summary>
        </member>
        <member name="M:Griffin.Security.PasswordHasherRfc2898.CreateSalt">
            <summary>
                Uses <c>RNGCryptoServiceProvider</c> to generate a 24 byte long salt which is then base64 encoded.
            </summary>
            <returns>Base64 encoded salt</returns>
        </member>
        <member name="M:Griffin.Security.PasswordHasherRfc2898.HashPassword(System.String,System.String)">
            <summary>
                Hashes password using 1000 iterations
            </summary>
            <param name="password">Password to hash</param>
            <param name="salt">Typically created with <see cref="M:Griffin.Security.PasswordHasherRfc2898.CreateSalt"/></param>
            <returns></returns>
            <remarks>
                <para>
                    The hash is generated from "password:salt" which is then hashed using <c>Rfc2898DeriveBytes</c> and 1000
                    iterations.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Security.PasswordHasherRfc2898.Compare(System.String,System.String)">
            <summary>
                Compares two passwords using a compare in length-constant time.
            </summary>
            <param name="hashedPassword1">First hash</param>
            <param name="hashedPassword2">Second hash</param>
            <returns><c>true</c> if they are equal; otherwise false.</returns>
        </member>
        <member name="M:Griffin.Security.PasswordHasherRfc2898.SlowEquals(System.Byte[],System.Byte[])">
            <summary>
                Compares two byte arrays in length-constant time. This comparison
                method is used so that password hashes cannot be extracted from
                on-line systems using a timing attack and then attacked off-line.
            </summary>
            <param name="a">The first byte array.</param>
            <param name="b">The second byte array.</param>
            <returns>True if both byte arrays are equal. False otherwise.</returns>
            <remarks>
                Credits: https://crackstation.net/hashing-security.htm#aspsourcecode
            </remarks>
        </member>
        <member name="T:Griffin.Signals.NamespaceDoc">
            <summary>
                Signals are used to keep track of important states in your application. You can for instance keep track
                of how you threads and background jobs are performing.
            </summary>
            <remarks>
            <para>
            Signals are integrated into:
            </para>
            <list type="bullet">
            <item> <see cref="T:Griffin.ApplicationServices.ApplicationServiceManager"/></item>
            <item> <see cref="T:Griffin.ApplicationServices.ApplicationServiceThread"/></item>
            <item> <see cref="T:Griffin.ApplicationServices.ApplicationServiceTimer"/></item>
            <item> <see cref="T:Griffin.ApplicationServices.BackgroundJobManager"/></item>
            </list>
            <para>
            which allows you to get state reports out of the box if you use those classes.
            </para>
                <para>
                    A basic example where a signal is used to prevent the log from getting spammed when message queue processing
                    fails:
                </para>
                <code>
            public void YourMethod()
            {
                while (!_shutDownSignal.Wait(0))
                {
                    try
                    {
                        var msg = _queue.ReadMessage();
                        
                        // process message
                        // [...]
                        
                        if (Signal.Reset("MyService.MessageReader"))
                            _logger.Info("We are fully functional again");
                    }
                    catch (Exception ex)
                    {
                        if (Signal.Raise("MyService.MessageReader"))
                        {
                            _logger.Fatal("MyService started to fail", ex);
                        }
                    }
                }
            }
            </code>
                <para>
                    Griffin.Framework will soon contain a lightweight server to allow you to receive the signals and get a quick
                    overview if everything in your application is working as expected. In the mean
                    time you can receive the signals in your own HTTP server by doing the following.
                </para>
                <para>
                    To start with you have to activate the submitter:
                </para>
                <code>
            SignalSubmitter.Configure("yourAppName", new Uri("http://yourServer/yourUrl"));
            SignalSubmitter.UploadAllSignals();
            </code>
                <para>
                    Once done you can simply raise the signal to get it uploaded:
                </para>
                <code>
            public void YourMethod()
            {
                while (!_shutDownSignal.Wait(0))
                {
                    try
                    {
                        var msg = _queue.ReadMessage();
                        
                        //process message
                        
                        Signal.Reset("MyService.MessageReader");
                    }
                    catch (Exception ex)
                    {
                        Signal.Raise("MyService.MessageReader");
                    }
                }
            }
            </code>
                <para>
                    For clarity you can also keep a reference to the signal:
                </para>
                <code>
            public class YourClass
            {
                Signal _readerSignal = Signal.Create("MyService.MessageReader");
                
                public void YourMethod()
                {
                    while (!_shutDownSignal.Wait(0))
                    {
                        try
                        {
                            var msg = _queue.ReadMessage();
                            
                            // process message
                            // [...]
            				
                            _readerSignal.Reset();
                        }
                        catch (Exception ex)
                        {
                            _readerSignal.Raise("Failed to read message", ex);
                        }
                    }
                }
            }
            
            </code>
            </remarks>
        </member>
        <member name="T:Griffin.Signals.Signal">
            <summary>
                Signals can be used to keep track of states in the application and to allow you to avoid spamming the log file
            </summary>
        </member>
        <member name="M:Griffin.Signals.Signal.Create(System.String)">
            <summary>
                Create a new signal
            </summary>
            <param name="signalName">Must be unique in the application</param>
            <returns>Created signal</returns>
            <remarks>
            </remarks>
            <exception cref="T:System.InvalidOperationException">A signal with that name have already been added.</exception>
        </member>
        <member name="M:Griffin.Signals.Signal.Create(System.String,Griffin.Signals.SignalKind)">
            <summary>
                Create a new signal
            </summary>
            <param name="signalName">Must be unique in the application</param>
            <param name="kind">Indicates if this signal represents that something is working or failing.</param>
            <returns>Created signal</returns>
            <remarks>
            </remarks>
            <exception cref="T:System.InvalidOperationException">A signal with that name have already been added.</exception>
        </member>
        <member name="M:Griffin.Signals.Signal.Disable">
            <summary>
                Disable notifications for this signal
            </summary>
        </member>
        <member name="M:Griffin.Signals.Signal.Enable">
            <summary>
                Enable notifications for this signal (if you have previously called <c>Disable()</c>).
            </summary>
        </member>
        <member name="M:Griffin.Signals.Signal.GetUserToken``1">
            <summary>
                Just a typed accessor for the <see cref="P:Griffin.Signals.Signal.UserToken"/>.
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <returns>Casted token</returns>
        </member>
        <member name="M:Griffin.Signals.Signal.Raise(System.String,System.String,System.Object[])">
            <summary>
                Raise a signal.
            </summary>
            <param name="signalName">Name of the signal</param>
            <param name="reason">Reason to why we are raising the signal</param>
            <param name="reasonFormatters">Formatters for <paramref name="reason" /> (like <c>string.Format()</c>)</param>
            <returns><c>true</c> if the signal was not already raised; <c>false</c> if it's already in signaled state.</returns>
            <remarks>
                <para>
                    Will create a new signal if no one have been registered with the specified name.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.Signal.Configure(System.String,System.Action{Griffin.Signals.Signal},System.Boolean)">
            <summary>
                Configure a signal
            </summary>
            <param name="signalName">Name of signal</param>
            <param name="configureMethod">Used to configure the signal</param>
            <param name="addIfMissing">Create it if it's missing.</param>
        </member>
        <member name="M:Griffin.Signals.Signal.Raise(System.String,System.String,System.Exception)">
            <summary>
                Raise a signal.
            </summary>
            <param name="signalName">Name of the signal</param>
            <param name="reason">Reason to why we are raising the signal</param>
            <param name="exception">Exception that caused the signal to be raised</param>
            <returns><c>true</c> if the signal was not already raised; <c>false</c> if it's already in signaled state.</returns>
            <remarks>
                <para>
                    Will create a new signal if no one have been registered with the specified name.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.Signal.Raise(System.String,System.Object[])">
            <summary>
                Raise a signal.
            </summary>
            <param name="reason">Reason to why we are raising the signal</param>
            <param name="reasonFormatters">Formatters for <paramref name="reason" /> (like <c>string.Format()</c>)</param>
            <returns><c>true</c> if the signal was not already raised; <c>false</c> if it's already in signaled state.</returns>
            <remarks>
                <para>
                    Will create a new signal if no one have been registered with the specified name.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.Signal.Raise(System.String,System.Exception)">
            <summary>
                Raise a signal.
            </summary>
            <param name="reason">Reason to why we are raising the signal</param>
            <param name="exception">Exception that caused the signal to be raised.</param>
            <returns><c>true</c> if the signal was not already raised; <c>false</c> if it's already in signaled state.</returns>
            <remarks>
                <para>
                    Will create a new signal if no one have been registered with the specified name.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.Signal.Reset(System.String)">
            <summary>
                Transition signal to non-signaled state.
            </summary>
            <param name="signalName">Signal to reset</param>
            <returns><c>true</c> if transition was made; <c>false</c> if the signal already was in non-signaled state.</returns>
        </member>
        <member name="M:Griffin.Signals.Signal.Reset">
            <summary>
                Transition signal to non-signaled state.
            </summary>
            <returns><c>true</c> if transition was made; <c>false</c> if the signal already was in non-signaled state.</returns>
        </member>
        <member name="M:Griffin.Signals.Signal.SuspendExpirations">
            <summary>
                Do not check signals for expirations
            </summary>
        </member>
        <member name="M:Griffin.Signals.Signal.Expire">
            <summary>
                Been signaled the configured amount of time, transition to non-signaled.
            </summary>
        </member>
        <member name="P:Griffin.Signals.Signal.IdleSinceUtc">
            <summary>
                When the signal was moved into non-signaled state.
            </summary>
        </member>
        <member name="P:Griffin.Signals.Signal.Name">
            <summary>
                Signal name
            </summary>
        </member>
        <member name="P:Griffin.Signals.Signal.IsRaised">
            <summary>
                Signal have been raised.
            </summary>
        </member>
        <member name="P:Griffin.Signals.Signal.Expiration">
            <summary>
                When the raised signaled is automatically suppressed again
            </summary>
            <remarks>
                <para>
                    Allows you to specify an amount of time
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Signals.Signal.Kind">
            <summary>
                Kind of signal
            </summary>
        </member>
        <member name="P:Griffin.Signals.Signal.RaisedSinceUtc">
            <summary>
                When the signal was raised
            </summary>
            <value>
                <c>DateTime.MinValue</c> if it's not raised.
            </value>
        </member>
        <member name="P:Griffin.Signals.Signal.Properties">
            <summary>
                Allows you to attach state etc
            </summary>
            <remarks>
                <para>
                    Typically used when you want to do additional filtering in the server that receives signal changes.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Signals.Signal.UserToken">
            <summary>
                A token which you can use to keep track of if the signal should be raised or not.
            </summary>
            <example>
                <code>
            var mySignal = 
            
            
            </code>
            </example>
        </member>
        <member name="P:Griffin.Signals.Signal.RaiseCountSinceLastReset">
            <summary>
                AMount of times that <c>Raise()</c> have been invoked since last reset.
            </summary>
        </member>
        <member name="E:Griffin.Signals.Signal.SignalRaised">
            <summary>
                One of the signals was raised.
            </summary>
        </member>
        <member name="E:Griffin.Signals.Signal.SignalSuppressed">
            <summary>
                One of the signals was reset
            </summary>
        </member>
        <member name="E:Griffin.Signals.Signal.Raised">
            <summary>
                Signal was raised.
            </summary>
        </member>
        <member name="E:Griffin.Signals.Signal.Suppressed">
            <summary>
                Signal was suppressed.
            </summary>
        </member>
        <member name="T:Griffin.Signals.SignalDTO">
            <summary>
                Used to transport data to a remote end point (typically a reporting service)
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.IdleSinceUtc">
            <summary>
                When the signal was moved into non-signaled state.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.Name">
            <summary>
                Signal name
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.ApplicationName">
            <summary>
                The application that the signal is for.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.IsRaised">
            <summary>
                Signal have been raised.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.RaisedSinceUtc">
            <summary>
                When the signal was raised
            </summary>
            <value>
                <c>DateTime.MinValue</c> if it's not raised.
            </value>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.UserToken">
            <summary>
                A token which you can use to keep track of if the signal should be raised or not.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.Reason">
            <summary>
            Why the signal was raised
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.CallingMethod">
            <summary>
            Method that raised the signal.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.Exception">
            <summary>
            Exception that caused the signal (if any)
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.Properties">
            <summary>
            Additional properties
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.Kind">
            <summary>
            "Undefined", "Running", "Fault"
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalDTO.RaiseCountSinceLastReset">
            <summary>
                AMount of times that <c>Raise()</c> have been invoked since last reset.
            </summary>
        </member>
        <member name="T:Griffin.Signals.SignalManager">
            <summary>
                Takes care of all signals
            </summary>
            <remarks>
                Allocated and used internally in <see cref="T:Griffin.Signals.Signal"/>.
            </remarks>
        </member>
        <member name="M:Griffin.Signals.SignalManager.#ctor">
            <summary>
                Manager.
            </summary>
        </member>
        <member name="M:Griffin.Signals.SignalManager.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Signals.SignalManager.GetOrAdd(System.String,System.Func{System.String,Griffin.Signals.Signal})">
            <summary>
            </summary>
            <param name="signalName"></param>
            <param name="addFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Signals.SignalManager.SuspendExpirations">
            <summary>
                Do not check signals for expirations
            </summary>
        </member>
        <member name="M:Griffin.Signals.SignalManager.Clear">
            <summary>
            Remove all mapped signals
            </summary>
        </member>
        <member name="T:Griffin.Signals.SignalRaisedEventArgs">
            <summary>
                Event for <see cref="T:Griffin.Signals.Signal"/>.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalRaisedEventArgs.SignalName">
            <summary>
            Name of the signal. 
            </summary>
            <remarks>
            <para>
            Actual signal is passed to the event as <c>sender</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Signals.SignalRaisedEventArgs.Reason">
            <summary>
            Why the signal was raised.
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalRaisedEventArgs.CallingMethod">
            <summary>
            Method that raised the signal
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalRaisedEventArgs.Exception">
            <summary>
            Exception that caused the signal (if any)
            </summary>
        </member>
        <member name="T:Griffin.Signals.SignalSubmitter">
            <summary>
                Used to post signals to a HTTP service.
            </summary>
            <remarks>
                <para>
                    Use <see cref="M:Griffin.Signals.SignalSubmitter.Configure(System.String,System.Uri)"/> to allow the submitter to upload reports. Then use <see cref="M:Griffin.Signals.SignalSubmitter.UploadAllSignals"/>
                    if you want the class to upload all signals, or manually subscribe
                    on <see cref="E:Griffin.Signals.Signal.SignalRaised"/> and <see cref="E:Griffin.Signals.Signal.SignalSuppressed"/> to upload signals by calling
                    <see cref="M:Griffin.Signals.SignalSubmitter.Send(Griffin.Signals.Signal)"/>.
                </para>
                <para>
                    Serializes the data to JSON (by using <see cref="T:Griffin.Signals.SignalDTO"/>) and then do a HTTP post to the server that you
                    configured by using .
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.SignalSubmitter.Configure(System.String,System.Uri)">
            <summary>
                Activate the submitter.
            </summary>
            <param name="applicationName">Your application name</param>
            <param name="destination"></param>
        </member>
        <member name="M:Griffin.Signals.SignalSubmitter.Send(Griffin.Signals.Signal)">
            <summary>
                Enqueue a signal for upload
            </summary>
            <param name="signal">signal to serialize as JSON and upload.</param>
            <remarks>
                <para>
                    The actual upload will be done in the background.
                </para>
                <para>
                    Will do nothing if <see cref="M:Griffin.Signals.SignalSubmitter.Configure(System.String,System.Uri)"/> have not been used.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.SignalSubmitter.Send(Griffin.Signals.SignalDTO)">
            <summary>
                Enqueue a signal for upload
            </summary>
            <param name="signal">signal to serialize as JSON and upload.</param>
            <remarks>
                <para>
                    The actual upload will be done in the background.
                </para>
                <para>
                    Will do nothing if <see cref="M:Griffin.Signals.SignalSubmitter.Configure(System.String,System.Uri)"/> have not been used.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Signals.SignalSubmitter.UploadAllSignals">
            <summary>
                Will subscribe on the <see cref="E:Griffin.Signals.Signal.SignalRaised"/> and <see cref="E:Griffin.Signals.Signal.SignalSuppressed"/> to be able to
                upload all signals.
            </summary>
            <exception cref="T:System.InvalidOperationException">You must Configure() first.</exception>
        </member>
        <member name="T:Griffin.Signals.SignalSuppressedEventArgs">
            <summary>
                Arguments for <see cref="E:Griffin.Signals.Signal.Suppressed"/>
            </summary>
        </member>
        <member name="M:Griffin.Signals.SignalSuppressedEventArgs.#ctor(System.String,System.String)">
            <summary>
                Create a new instance of <see cref="T:Griffin.Signals.SignalRaisedEventArgs"/>.
            </summary>
            <param name="signalName">Name of the suppressed signal (as registered by <c>Signal.Create()</c>).</param>
            <param name="callingMethod">Type/Method that suppressed the signal</param>
        </member>
        <member name="P:Griffin.Signals.SignalSuppressedEventArgs.SignalName">
            <summary>
                Name of the suppressed signal (as registered by <c>Signal.Create()</c>)
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalSuppressedEventArgs.CallingMethod">
            <summary>
                Type/Method that suppressed the signal
            </summary>
        </member>
        <member name="P:Griffin.Signals.SignalSuppressedEventArgs.Automated">
            <summary>
                Signal was by automation (typically by expiry).
            </summary>
        </member>
        <member name="T:Griffin.Signals.SignalKind">
            <summary>
            Kind of signal
            </summary>
        </member>
        <member name="F:Griffin.Signals.SignalKind.Undefined">
            <summary>
            Not specified, might indicate that something is failing or working.
            </summary>
        </member>
        <member name="F:Griffin.Signals.SignalKind.Running">
            <summary>
            Running as expected
            </summary>
        </member>
        <member name="F:Griffin.Signals.SignalKind.Fault">
            <summary>
            Fault state
            </summary>
        </member>
        <member name="T:Griffin.TypeExtensions">
            <summary>
                Extension methods for <c>Type</c>.
            </summary>
        </member>
        <member name="M:Griffin.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
                Get assembly qualified name, but without the version and public token.
            </summary>
            <param name="type">Type to get name for</param>
            <returns>Simple assembly qualified name. Example: <code>"MyApp.Contracts.User, MyApp.Contracts"</code></returns>
        </member>
        <member name="M:Griffin.TypeExtensions.GetFriendlyTypeName(System.Type)">
            <summary>
                Get type name as we define it in code.
            </summary>
            <param name="t">The type to get a name for.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Griffin.TypeExtensions.IsAssignableFromGeneric(System.Type,System.Type)">
            <summary>
                Check if generic types matches
            </summary>
            <param name="serviceType">Service/interface</param>
            <param name="concreteType">Concrete/class</param>
            <returns><c>true</c> if the concrete implements the service; otherwise <c>false</c></returns>
        </member>
        <member name="M:Griffin.TypeExtensions.IsSimpleType(System.Type)">
            <summary>
                Checks if the specified type is a type which should not be traversed when building an object hiararchy.
            </summary>
            <param name="type">Type to check</param>
            <returns><c>true</c> if it's a simple type; otherwise <c>false</c>.</returns>
            <example>
                <code>
            public string Build(object instance)
            {
                var sb = new StringBuilder();
                Build(instance, "", sb);
                return sb.ToString();
            }
            
            protected void Build(object instance, string prefix, StringBuilder result)
            {
                foreach (var propInfo in instance.GetType().GetProperties())
                {
                    if (instance.GetType().IsSimpleType())
                    {
                        var value = propInfo.GetValue(instance, null);
                        result.AppendLine(prefix + propInfo.Name + ": " + value);
                    }
                    else
                    {
                        var newPrefix = prefix == "" ? propInfo.Name : prefix + ".";
                        Build(newPrefix, 
            }
            
            while (!type.IsSimpleType())
            {
            }
            
            </code>
            </example>
        </member>
        <member name="T:Griffin.WaitHandleExtensions">
            <summary>
            Extensions to make it easier to work with thread synchronization objects.
            </summary>
        </member>
        <member name="M:Griffin.WaitHandleExtensions.AsTask(System.Threading.WaitHandle)">
            <summary>
            Convert a wait handle to a TPL Task.
            </summary>
            <param name="handle">Handle to convert</param>
            <returns>Generated task.</returns>
            
        </member>
        <member name="M:Griffin.WaitHandleExtensions.AsTask(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Convert a wait handle to a task
            </summary>
            <param name="handle">Wait handle</param>
            <param name="timeout">Max time to wait</param>
            <returns>Created task.</returns>
        </member>
    </members>
</doc>
